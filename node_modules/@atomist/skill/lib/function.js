"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.processWebhook = exports.processCommand = exports.processEvent = exports.entryPoint = void 0;
// tslint:disable-next-line:no-import-side-effect
require("source-map-support/register");
const action_1 = require("./action");
const context_1 = require("./context");
const log_1 = require("./log");
const message_1 = require("./message");
const payload_1 = require("./payload");
const payload_resolve_1 = require("./payload_resolve");
const prompt_1 = require("./prompt/prompt");
const util_1 = require("./util");
const entryPoint = async (pubSubEvent, context) => {
    const payload = await payload_resolve_1.resolvePayload(pubSubEvent);
    if (payload_1.isEventIncoming(payload) || payload_1.isSubscriptionIncoming(payload)) {
        await processEvent(payload, context);
    }
    else if (payload_1.isCommandIncoming(payload)) {
        await processCommand(payload, context);
    }
    else if (payload_1.isWebhookIncoming(payload)) {
        await processWebhook(payload, context);
    }
};
exports.entryPoint = entryPoint;
async function processEvent(event, ctx, loader = action_1.eventHandlerLoader("events"), factory = context_1.createContext) {
    const context = factory(event, ctx);
    log_1.debug(`Incoming event message: ${JSON.stringify(event, util_1.replacer)}`);
    if (payload_1.isSubscriptionIncoming(event)) {
        log_1.debug(`Invoking event handler '${context.name}' for tx '${event.subscription.tx}'`);
    }
    else {
        log_1.debug(`Invoking event handler '${context.name}'`);
    }
    try {
        const result = await invokeHandler(loader, context);
        await context.message.publish(message_1.prepareStatus(result || { code: 0 }, context));
    }
    catch (e) {
        await publishError(e, context);
    }
    finally {
        log_1.debug(`Completed event handler '${context.name}'`);
        await context.close();
    }
}
exports.processEvent = processEvent;
async function processCommand(event, ctx, loader = util_1.handlerLoader("commands"), factory = context_1.createContext) {
    const context = factory(event, ctx);
    log_1.debug(`Incoming command message: ${JSON.stringify(event, util_1.replacer)}`);
    log_1.debug(`Invoking command handler '${context.name}'`);
    try {
        const result = await invokeHandler(loader, context);
        await context.message.publish(message_1.prepareStatus(result || { code: 0 }, context));
    }
    catch (e) {
        if (e instanceof prompt_1.CommandListenerExecutionInterruptError) {
            await context.message.publish(message_1.prepareStatus({ code: 0 }, context));
        }
        else {
            await publishError(e, context);
        }
    }
    finally {
        log_1.debug(`Completed command handler '${context.name}'`);
        await context.close();
    }
}
exports.processCommand = processCommand;
async function processWebhook(event, ctx, loader = util_1.handlerLoader("webhooks"), factory = context_1.createContext) {
    const context = factory(event, ctx);
    log_1.debug(`Incoming webhook message: ${JSON.stringify(event, util_1.replacer)}`);
    log_1.debug(`Invoking webhook handler '${context.name}'`);
    try {
        const result = await invokeHandler(loader, context);
        await context.message.publish(message_1.prepareStatus(result || { code: 0 }, context));
    }
    catch (e) {
        await publishError(e, context);
    }
    finally {
        log_1.debug(`Completed webhook handler '${context.name}'`);
        await context.close();
    }
}
exports.processWebhook = processWebhook;
async function invokeHandler(loader, context) {
    const result = (await (await loader(context.name))(context));
    return result;
}
async function publishError(e, context) {
    log_1.error(`Error occurred: ${e.stack}`);
    await context.message.publish(message_1.prepareStatus(e, context));
}
//# sourceMappingURL=function.js.map