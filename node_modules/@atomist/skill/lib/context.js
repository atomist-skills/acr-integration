"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractConfiguration = exports.createContext = void 0;
const client_1 = require("./datalog/client");
const graphql_1 = require("./graphql");
const http_1 = require("./http");
const console_1 = require("./log/console");
const util_1 = require("./log/util");
const map_1 = require("./map");
const message_1 = require("./message");
const payload_1 = require("./payload");
const loader_1 = require("./project/loader");
const prompt_1 = require("./prompt/prompt");
const provider_1 = require("./secret/provider");
const provider_2 = require("./storage/provider");
const util_2 = require("./util");
function createContext(payload, ctx) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const apiKey = (_b = (_a = payload === null || payload === void 0 ? void 0 : payload.secrets) === null || _a === void 0 ? void 0 : _a.find(s => s.uri === "atomist://api-key")) === null || _b === void 0 ? void 0 : _b.value;
    const wid = payload_1.workspaceId(payload);
    const graphql = graphql_1.createGraphQLClient(apiKey, wid);
    const storage = provider_2.createStorageProvider(wid);
    const credential = new provider_1.DefaultCredentialProvider(graphql, payload);
    const completeCallbacks = [];
    const onComplete = closable => {
        completeCallbacks.push(closable);
    };
    const close = async () => {
        let callback = completeCallbacks.pop();
        while (callback) {
            await util_2.handleError(callback);
            callback = completeCallbacks.pop();
        }
    };
    let context;
    if (payload_1.isCommandIncoming(payload)) {
        if (payload.raw_message) {
            const parameters = util_2.extractParameters(payload.raw_message);
            payload.parameters.push(...parameters);
        }
        const message = new message_1.PubSubCommandMessageClient(payload, graphql);
        context = Object.assign(Object.assign({ parameters: {
                prompt: prompt_1.commandRequestParameterPromptFactory(message, payload),
            }, name: payload.command, correlationId: payload.correlation_id, executionId: ctx.eventId, workspaceId: wid, credential,
            graphql, http: http_1.createHttpClient(), storage,
            message, datalog: client_1.createDatalogClient(apiKey, wid, payload.correlation_id, payload.skill), project: loader_1.createProjectLoader({ onComplete }), trigger: payload }, extractConfiguration(payload)), { skill: payload.skill, close,
            onComplete });
    }
    else if (payload_1.isEventIncoming(payload)) {
        context = {
            data: payload.data,
            name: payload.extensions.operationName,
            correlationId: payload.extensions.correlation_id,
            executionId: ctx.eventId,
            workspaceId: wid,
            credential,
            graphql,
            http: http_1.createHttpClient(),
            storage,
            message: new message_1.PubSubEventMessageClient(payload, graphql, payload.extensions.team_id, payload.extensions.team_name, payload.extensions.operationName, payload.extensions.correlation_id),
            datalog: client_1.createDatalogClient(apiKey, wid, payload.extensions.correlation_id, payload.skill),
            project: loader_1.createProjectLoader({ onComplete }),
            trigger: payload,
            configuration: (_d = (_c = extractConfiguration(payload)) === null || _c === void 0 ? void 0 : _c.configuration) === null || _d === void 0 ? void 0 : _d[0],
            skill: payload.skill,
            close,
            onComplete,
        };
    }
    else if (payload_1.isSubscriptionIncoming(payload)) {
        context = {
            data: util_2.toArray((_e = payload.subscription) === null || _e === void 0 ? void 0 : _e.result).map(map_1.mapSubscription),
            name: (_f = payload.subscription) === null || _f === void 0 ? void 0 : _f.name,
            correlationId: payload.correlation_id,
            executionId: ctx.eventId,
            workspaceId: wid,
            credential,
            graphql,
            http: http_1.createHttpClient(),
            storage,
            message: new message_1.PubSubEventMessageClient(payload, graphql, payload.team_id, payload.team_id, (_g = payload.subscription) === null || _g === void 0 ? void 0 : _g.name, payload.correlation_id),
            datalog: client_1.createDatalogClient(apiKey, wid, payload.correlation_id, payload.skill),
            project: loader_1.createProjectLoader({ onComplete }),
            trigger: payload,
            configuration: (_j = (_h = extractConfiguration(payload)) === null || _h === void 0 ? void 0 : _h.configuration) === null || _j === void 0 ? void 0 : _j[0],
            skill: payload.skill,
            close,
            onComplete,
        };
    }
    else if (payload_1.isWebhookIncoming(payload)) {
        context = {
            name: payload.webhook.parameter_name,
            body: payload.webhook.body,
            get json() {
                return JSON.parse(payload.webhook.body);
            },
            headers: payload.webhook.headers,
            url: payload.webhook.url,
            correlationId: payload.correlation_id,
            executionId: ctx.eventId,
            workspaceId: wid,
            credential,
            graphql,
            http: http_1.createHttpClient(),
            storage,
            message: new message_1.PubSubWebhookMessageClient(payload, graphql),
            datalog: client_1.createDatalogClient(apiKey, wid, payload.correlation_id, payload.skill),
            project: loader_1.createProjectLoader(),
            trigger: payload,
            configuration: (_l = (_k = extractConfiguration(payload)) === null || _k === void 0 ? void 0 : _k.configuration) === null || _l === void 0 ? void 0 : _l[0],
            skill: payload.skill,
            close,
            onComplete,
        };
    }
    if (context) {
        util_1.initLogging({
            skillId: payload.skill.id,
            eventId: ctx.eventId,
            correlationId: context.correlationId,
            workspaceId: wid,
        }, onComplete, {
            name: context.name,
            skill: `${payload.skill.namespace}/${payload.skill.name}@${payload.skill.version}`,
        });
        const rt = util_1.runtime();
        console_1.debug("Starting %s/%s:%s '%s' %satomist/skill:%s (%s) nodejs:%s", payload.skill.namespace, payload.skill.name, payload.skill.version, context.name, ((_m = rt.host) === null || _m === void 0 ? void 0 : _m.sha) ? `(${rt.host.sha.slice(0, 7)}) ` : "", rt.skill.version, rt.skill.sha.slice(0, 7), rt.node.version);
    }
    return context;
}
exports.createContext = createContext;
function extractConfiguration(payload) {
    var _a, _b, _c;
    const cfgs = [];
    if ((_b = (_a = payload.skill) === null || _a === void 0 ? void 0 : _a.configuration) === null || _b === void 0 ? void 0 : _b.instances) {
        cfgs.push(...payload.skill.configuration.instances);
    }
    else if ((_c = payload.skill) === null || _c === void 0 ? void 0 : _c.configuration) {
        cfgs.push(payload.skill.configuration);
    }
    return {
        configuration: cfgs.map(c => ({
            name: c.name,
            parameters: extractConfigurationParameters(c.parameters),
            resourceProviders: extractConfigurationResourceProviders(c.resourceProviders),
            url: `https://go.atomist.com/${payload_1.workspaceId(payload)}/manage/skills/configure/edit/${payload.skill.namespace}/${payload.skill.name}/${encodeURIComponent(c.name)}`,
        })),
    };
}
exports.extractConfiguration = extractConfiguration;
function extractConfigurationParameters(params) {
    const parameters = {};
    params === null || params === void 0 ? void 0 : params.forEach(p => (parameters[p.name] = p.value));
    return parameters;
}
function extractConfigurationResourceProviders(params) {
    const resourceProviders = {};
    params === null || params === void 0 ? void 0 : params.forEach(p => (resourceProviders[p.name] = {
        typeName: p.typeName,
        selectedResourceProviders: p.selectedResourceProviders,
    }));
    return resourceProviders;
}
//# sourceMappingURL=context.js.map