"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.truncateText = exports.createCheck = void 0;
const util_1 = require("../log/util");
const payload_1 = require("../payload");
const util_2 = require("../util");
const operation_1 = require("./operation");
const chunk = require("lodash.chunk");
const sortBy = require("lodash.sortby");
async function createCheck(ctx, id, parameters) {
    var _a;
    let terminated = false;
    const externalId = payload_1.isSubscriptionIncoming(ctx.trigger)
        ? ctx.trigger.subscription.tx.toString()
        : ctx.correlationId;
    // Check if there is a check open with that name
    const openChecks = (await operation_1.api(id).checks.listForRef({
        owner: id.owner,
        repo: id.repo,
        ref: parameters.sha,
        check_name: parameters.name,
        status: parameters.reuse ? undefined : "in_progress",
        filter: "latest",
    })).data;
    ctx.onComplete(async () => {
        if (!terminated && check) {
            await operation_1.api(id).checks.update({
                owner: id.owner,
                repo: id.repo,
                check_run_id: check.data.id,
                conclusion: "failure",
                completed_at: new Date().toISOString(),
                status: "completed",
            });
            terminated = true;
        }
    });
    let check;
    // Work around issues with our staging bot trying to update checks from production
    const app = util_2.isStaging() ? "atomista" : "atomist";
    const openCheck = (_a = openChecks === null || openChecks === void 0 ? void 0 : openChecks.check_runs) === null || _a === void 0 ? void 0 : _a.find(cr => cr.app.slug === app);
    if (openCheck) {
        check = await operation_1.api(id).checks.update({
            owner: id.owner,
            repo: id.repo,
            check_run_id: openCheck.id,
            started_at: parameters.startedAt || new Date().toISOString(),
            external_id: externalId,
            details_url: util_1.url(ctx),
            status: "in_progress",
            conclusion: undefined,
            output: {
                title: parameters.title,
                summary: truncateText(`${parameters.body}\n${operation_1.formatFooter(ctx)}\n${operation_1.formatMarkers(ctx)}`),
                details: parameters.details
                    ? truncateText(parameters.details)
                    : undefined,
                annotations: [],
            },
        });
    }
    else {
        check = await operation_1.api(id).checks.create({
            owner: id.owner,
            repo: id.repo,
            head_sha: parameters.sha,
            name: parameters.name,
            started_at: parameters.startedAt || new Date().toISOString(),
            external_id: externalId,
            details_url: util_1.url(ctx),
            status: "in_progress",
            output: {
                title: parameters.title,
                summary: truncateText(`${parameters.body}\n${operation_1.formatFooter(ctx)}\n${operation_1.formatMarkers(ctx)}`),
                details: parameters.details
                    ? truncateText(parameters.details)
                    : undefined,
                annotations: [],
            },
        });
    }
    return {
        data: check.data,
        update: async (params) => {
            const gh = operation_1.api(id);
            const output = {
                title: check.data.output.title,
                summary: truncateText(params.body
                    ? `${params.body}\n${operation_1.formatFooter(ctx)}\n${operation_1.formatMarkers(ctx)}`
                    : check.data.output.summary),
                details: parameters.details
                    ? truncateText(parameters.details)
                    : undefined,
            };
            const chunks = chunk(sortBy((params.annotations || []).map(c => ({
                annotation_level: c.annotationLevel,
                title: c.title,
                end_column: c.endColumn,
                end_line: c.endLine,
                message: c.message,
                path: c.path,
                start_column: c.startColumn,
                start_line: c.startLine,
            })), ["path", "start_line", "start_column", "title", "message"]), 50);
            for (const ch of chunks) {
                await gh.checks.update({
                    owner: id.owner,
                    repo: id.repo,
                    check_run_id: check.data.id,
                    output: Object.assign(Object.assign({}, output), { annotations: ch }),
                });
            }
            await gh.checks.update({
                owner: id.owner,
                repo: id.repo,
                check_run_id: check.data.id,
                conclusion: params.conclusion,
                completed_at: params.conclusion
                    ? new Date().toISOString()
                    : undefined,
                status: params.conclusion ? "completed" : "in_progress",
                output,
                actions: params.actions,
            });
            if (params.conclusion) {
                terminated = true;
            }
        },
    };
}
exports.createCheck = createCheck;
/**
 * Truncate the text to the desired number of bytes. Characters are
 * removed from the middle of the text and replaced with an ellipsis.
 */
function truncateText(text, length = 65535) {
    const trimmed = text.trim();
    if (Buffer.byteLength(trimmed) <= length) {
        return trimmed;
    }
    const ellipsis = " ... ";
    const retain = Math.floor((length - ellipsis.length) / 2);
    const chunks = [
        trimmed.slice(0, retain + 1).trim(),
        trimmed.slice(-1 * retain).trim(),
    ];
    let trimIndex = 1;
    while (Buffer.byteLength(`${chunks[0]}${ellipsis}${chunks[1]}`) > length) {
        if (trimIndex === 0) {
            chunks[0] = chunks[0].slice(0, chunks[0].length - 1).trim();
            trimIndex = 1;
        }
        else {
            chunks[1] = chunks[1].slice(1).trim();
            trimIndex = 0;
        }
    }
    return `${chunks[0]}${ellipsis}${chunks[1]}`;
}
exports.truncateText = truncateText;
//# sourceMappingURL=check.js.map