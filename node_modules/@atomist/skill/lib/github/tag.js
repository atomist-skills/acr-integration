"use strict";
/*
 * Copyright Â© 2020 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.incrementTag = exports.nextTag = void 0;
const semver = require("semver");
const console_1 = require("../log/console");
const operation_1 = require("./operation");
async function nextTag(id, increment = "prerelease", startTag = "0.1.0-0") {
    var e_1, _a;
    const github = operation_1.api(id);
    const tags = [];
    try {
        for (var _b = __asyncValues(github.paginate.iterator(github.repos.listTags, {
            owner: id.owner,
            repo: id.repo,
            per_page: 200,
        })), _c; _c = await _b.next(), !_c.done;) {
            const response = _c.value;
            tags.push(...response.data.map(t => t.name));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return incrementTag(tags, increment, startTag);
}
exports.nextTag = nextTag;
function incrementTag(tags, increment = "prerelease", startTag = "0.1.0-0") {
    const sortedTags = tags
        .filter(t => semver.valid(t))
        .sort((t1, t2) => {
        return semver.compare(t2, t1);
    });
    if (sortedTags.length === 0) {
        return startTag;
    }
    const latestTag = sortedTags[0];
    const nextTag = semver.inc(latestTag, increment);
    console_1.debug(`Calculated next tag '${nextTag}' from current tag '${latestTag}'`);
    return nextTag;
}
exports.incrementTag = incrementTag;
//# sourceMappingURL=tag.js.map