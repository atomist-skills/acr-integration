"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.runSteps = void 0;
const log_1 = require("./log");
const util_1 = require("./util");
/**
 * Execute provided skill steps in the order they are provided or until one fails
 */
async function runSteps(options) {
    var _a;
    const parameters = options.parameters || {};
    const context = options.context;
    const listeners = util_1.toArray(options.listeners) || [];
    let result;
    for (const step of util_1.toArray(options.steps)) {
        try {
            if (!step.runWhen || !!(await step.runWhen(context, parameters))) {
                log_1.info(`Running '${step.name}'`);
                await invokeListeners(listeners.filter(l => !!l.starting), async (l) => l.starting(step, parameters));
                const sr = await step.run(context, parameters);
                if (sr) {
                    result = {
                        code: (sr === null || sr === void 0 ? void 0 : sr.code) !== undefined
                            ? sr.code
                            : (result || {}).code,
                        reason: (sr === null || sr === void 0 ? void 0 : sr.reason) ? sr.reason : (result || {}).reason,
                        visibility: (sr === null || sr === void 0 ? void 0 : sr.visibility)
                            ? sr.visibility
                            : (result || {}).visibility,
                    };
                }
                await invokeListeners(listeners.filter(l => !!l.completed), async (l) => l.completed(step, parameters, sr));
                if ((_a = sr) === null || _a === void 0 ? void 0 : _a._abort) {
                    log_1.info(`Completed '${step.name}' and exited`);
                    return sr;
                }
                else if ((sr === null || sr === void 0 ? void 0 : sr.code) !== 0) {
                    log_1.warn(`'${step.name}' errored with: ${sr.reason}`);
                    return sr;
                }
                else if (sr === null || sr === void 0 ? void 0 : sr.reason) {
                    log_1.info(`Completed '${step.name}' with: ${sr.reason}`);
                }
                else {
                    log_1.info(`Completed '${step.name}'`);
                }
            }
            else {
                log_1.info(`Skipping '${step.name}'`);
                await invokeListeners(listeners.filter(l => !!l.skipped), async (l) => l.skipped(step, parameters));
            }
        }
        catch (e) {
            log_1.warn(`'${step.name}' errored with: ${e.message}`);
            log_1.warn(e.stack);
            await invokeListeners(listeners.filter(l => !!l.failed), async (l) => l.failed(step, parameters, e));
            return {
                code: 1,
                reason: `'${step.name}' errored`,
            };
        }
    }
    return invokeDone(listeners.filter(l => !!l.done), parameters, result);
}
exports.runSteps = runSteps;
async function invokeListeners(listeners, cb) {
    for (const listener of listeners) {
        try {
            await cb(listener);
        }
        catch (e) {
            log_1.warn("Listener failed with");
            log_1.warn(e);
        }
    }
}
async function invokeDone(listeners, parameters, inputResult) {
    let result = inputResult;
    for (const listener of listeners) {
        try {
            result = await listener.done(parameters, result);
        }
        catch (e) {
            log_1.warn("Listener failed with:");
            log_1.warn(e);
        }
    }
    return result;
}
//# sourceMappingURL=steps.js.map