"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareStatus = exports.PubSubWebhookMessageClient = exports.PubSubEventMessageClient = exports.PubSubCommandMessageClient = exports.isFileMessage = exports.isSlackMessage = exports.mapBlockActions = exports.mapActions = exports.AbstractMessageClient = exports.MessageClientSupport = exports.MessageMimeTypes = exports.AttachmentTarget = void 0;
const slack_messages_1 = require("@atomist/slack-messages");
const pubsub_1 = require("@google-cloud/pubsub");
const log_1 = require("./log");
const payload_1 = require("./payload");
const util_1 = require("./util");
const cloneDeep = require("lodash.clonedeep");
var AttachmentTarget;
(function (AttachmentTarget) {
    AttachmentTarget["Push"] = "push";
    AttachmentTarget["Commit"] = "commit";
})(AttachmentTarget = exports.AttachmentTarget || (exports.AttachmentTarget = {}));
/** Valid MessageClient types. */
exports.MessageMimeTypes = {
    SLACK_JSON: "application/x-atomist-slack+json",
    SLACK_FILE_JSON: "application/x-atomist-slack-file+json",
    PLAIN_TEXT: "text/plain",
    APPLICATION_JSON: "application/json",
};
class MessageClientSupport {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    respond(msg, options) {
        return this.doSend(msg, { users: [], channels: [] }, options);
    }
    send(
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    msg, destinations, options) {
        return this.doSend(msg, destinations, options);
    }
}
exports.MessageClientSupport = MessageClientSupport;
const CreateLifecycleAttachmentMutation = `mutation createLifecycleAttachment($value: CustomLifecycleAttachmentInput!) {
  ingestCustomLifecycleAttachment(value: $value)
}`;
class AbstractMessageClient extends MessageClientSupport {
    constructor(request, correlationId, team, source, graphClient) {
        super();
        this.request = request;
        this.correlationId = correlationId;
        this.team = team;
        this.source = source;
        this.graphClient = graphClient;
    }
    async delete(destinations, options) {
        return this.doSend(undefined, destinations, Object.assign(Object.assign({}, options), { delete: true }));
    }
    async attach(attachment, target, identifier, name, ts) {
        var _a, _b;
        await this.graphClient.mutate(CreateLifecycleAttachmentMutation, {
            value: {
                type: target,
                identifier,
                skill: `${this.request.skill.namespace}/${this.request.skill.name}`,
                // TODO cd for commands we could end up with more then one configuration
                configuration: (_b = (_a = util_1.toArray(this.request.skill.configuration)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.name,
                name,
                ts,
                body: JSON.stringify(attachment),
                contentType: exports.MessageMimeTypes.SLACK_JSON,
            },
        });
    }
    async doSend(
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    msg, destinations, options = {}) {
        var _a, _b, _c, _d, _e;
        if (!!msg &&
            msg.content_type ===
                "application/x-atomist-continuation+json") {
            return this.sendResponse(msg).then(() => msg);
        }
        const ts = this.ts(options);
        const responseDestinations = [];
        let threadTs;
        if (options.thread === true && !!this.source) {
            threadTs = (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.slack) === null || _b === void 0 ? void 0 : _b.message.ts;
        }
        else if (typeof options.thread === "string") {
            threadTs = options.thread;
        }
        const teamId = await this.getTeamId((_e = (_d = (_c = this.source) === null || _c === void 0 ? void 0 : _c.slack) === null || _d === void 0 ? void 0 : _d.team) === null || _e === void 0 ? void 0 : _e.id, this.graphClient);
        util_1.toArray(destinations.users || []).forEach(d => {
            responseDestinations.push({
                user_agent: "slack",
                slack: {
                    team: {
                        id: teamId,
                    },
                    user: {
                        name: d,
                    },
                    thread_ts: threadTs,
                },
            });
        });
        util_1.toArray(destinations.channels || []).forEach(d => {
            responseDestinations.push({
                user_agent: "slack",
                slack: {
                    team: {
                        id: teamId,
                    },
                    channel: {
                        name: d,
                    },
                    thread_ts: threadTs,
                },
            });
        });
        if (responseDestinations.length === 0 && this.source) {
            const responseDestination = cloneDeep(this.source);
            if (responseDestination.slack) {
                delete responseDestination.slack.user;
                if (threadTs) {
                    responseDestination.slack.thread_ts = threadTs;
                }
            }
            responseDestinations.push(responseDestination);
        }
        const response = {
            api_version: "1",
            correlation_id: this.correlationId,
            team: this.team,
            source: this.source ? this.source : undefined,
            command: payload_1.isCommandIncoming(this.request)
                ? this.request.command
                : undefined,
            event: payload_1.isEventIncoming(this.request)
                ? this.request.extensions.operationName
                : payload_1.isSubscriptionIncoming(this.request)
                    ? this.request.subscription.name
                    : undefined,
            destinations: responseDestinations,
            id: options.id ? options.id : undefined,
            timestamp: ts,
            ttl: ts && options.ttl ? options.ttl : undefined,
            post_mode: options.post === "update_only"
                ? "update_only"
                : options.post === "always"
                    ? "always"
                    : "ttl",
            skill: this.request.skill,
        };
        if (isSlackMessage(msg)) {
            const msgClone = cloneDeep(msg);
            const actions = mapActions(msgClone);
            const blockActions = mapBlockActions(msgClone);
            response.content_type = exports.MessageMimeTypes.SLACK_JSON;
            response.body = slack_messages_1.render(msgClone, false);
            response.actions = [
                ...(actions || []),
                ...(blockActions || []),
                ...(options.actions || []),
            ];
        }
        else if (isFileMessage(msg)) {
            response.content_type = exports.MessageMimeTypes.SLACK_FILE_JSON;
            response.body = JSON.stringify({
                content: msg.content,
                filename: msg.fileName,
                filetype: msg.fileType,
                title: msg.title,
                initial_comment: msg.comment,
            });
        }
        else if (typeof msg === "string") {
            response.content_type = exports.MessageMimeTypes.PLAIN_TEXT;
            response.body = msg;
        }
        else if (options.delete) {
            response.content_type = "application/x-atomist-delete";
            response.body = undefined;
        }
        return this.sendResponse(response).then(() => response);
    }
    ts(options) {
        if (options.id) {
            if (options.ts) {
                return options.ts;
            }
            else {
                return Date.now();
            }
        }
        else {
            return undefined;
        }
    }
    async getTeamId(teamId, graphClient) {
        var _a;
        if (teamId) {
            return teamId;
        }
        else {
            const query = `query ChatTeam { ChatTeam { id } }`;
            const result = await graphClient.query(query);
            return (_a = result === null || result === void 0 ? void 0 : result.ChatTeam[0]) === null || _a === void 0 ? void 0 : _a.id;
        }
    }
}
exports.AbstractMessageClient = AbstractMessageClient;
function mapActions(msg) {
    const actions = [];
    let counter = 0;
    if (msg.attachments) {
        msg.attachments
            .filter(attachment => attachment.actions)
            .forEach(attachment => {
            attachment.actions.forEach(a => {
                if (!!a && !!a.command) {
                    const cra = a;
                    const id = counter++;
                    cra.command.id = `${cra.command.id}-${id}`;
                    a.name = `${a.name}-${id}`;
                    const action = {
                        id: cra.command.id,
                        parameter_name: cra.command.parameterName,
                        command: cra.command.name,
                        parameters: mapParameters(cra.command.parameters),
                    };
                    actions.push(action);
                    // Lastly we need to delete our extension from the slack action
                    cra.command = undefined;
                }
            });
        });
    }
    return actions;
}
exports.mapActions = mapActions;
function mapBlockActions(msg) {
    const actions = [];
    let counter = 0;
    const mapElement = (element) => {
        if (element.command) {
            const id = counter++;
            const cra = element.command;
            const action = {
                id: `${cra.name}-${id}`,
                command: cra.name,
                parameters: mapParameters(cra.parameters),
                parameter_name: cra.parameterName,
            };
            actions.push(action);
            delete element.command;
            element.action_id = `command::${action.id}`;
        }
        else if (element.modal) {
            const id = counter++;
            const cra = element.modal;
            const action = {
                id: `${cra.name}-${id}`,
                command: cra.name,
                parameters: [
                    {
                        name: "view",
                        value: JSON.stringify(cra.view),
                    },
                ],
            };
            actions.push(action);
            delete element.modal;
            element.action_id = `modal::${action.id}`;
        }
    };
    if (msg.blocks) {
        msg.blocks.forEach(block => {
            var _a;
            if (block.type === "section") {
                const sectionBlock = block;
                if (sectionBlock.accessory) {
                    mapElement(sectionBlock.accessory);
                }
            }
            else if (block.type === "actions") {
                const actionsBlock = block;
                if (((_a = actionsBlock.elements) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                    actionsBlock.elements.forEach(mapElement);
                }
            }
        });
    }
    return actions;
}
exports.mapBlockActions = mapBlockActions;
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function mapParameters(data) {
    const parameters = [];
    for (const key in data) {
        const value = data[key];
        if (value) {
            parameters.push({
                name: key,
                value: value.toString(),
            });
        }
        else {
            // logger.debug(`Parameter value for '${key}' is null`);
        }
    }
    return parameters;
}
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function isSlackMessage(object) {
    return (!!object &&
        (object.text || object.attachments || object.blocks) &&
        !object.content);
}
exports.isSlackMessage = isSlackMessage;
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function isFileMessage(object) {
    return !!object && !object.length && object.content;
}
exports.isFileMessage = isFileMessage;
class AbstractPubSubMessageClient extends AbstractMessageClient {
    constructor(request, correlationId, team, source, workspaceId, graphClient) {
        super(request, correlationId, team, source, graphClient);
        this.request = request;
        this.correlationId = correlationId;
        this.team = team;
        this.source = source;
        this.workspaceId = workspaceId;
        this.graphClient = graphClient;
    }
    async sendResponse(message) {
        const topicName = process.env.ATOMIST_TOPIC ||
            `${this.workspaceId}-${this.request.skill.id}-response`;
        try {
            log_1.debug(`Sending message: ${JSON.stringify(message, util_1.replacer)}`);
            if (!this.topic) {
                this.topic = new pubsub_1.PubSub().topic(topicName, {
                    messageOrdering: true,
                });
            }
            const messageBuffer = Buffer.from(JSON.stringify(message), "utf8");
            await this.topic.publishMessage({
                data: messageBuffer,
                orderingKey: this.correlationId,
            });
        }
        catch (err) {
            log_1.error(`Error occurred sending message: ${err.message}`);
        }
    }
}
class PubSubCommandMessageClient extends AbstractPubSubMessageClient {
    constructor(request, graphClient) {
        super(request, request.correlation_id, request.team, request.source, request.team.id, graphClient);
        this.request = request;
        this.graphClient = graphClient;
    }
    async doSend(msg, destinations, options = {}) {
        return super.doSend(msg, destinations, options);
    }
    async publish(status) {
        const source = cloneDeep(this.request.source);
        if (source && source.slack) {
            delete source.slack.user;
        }
        const response = {
            api_version: "1",
            correlation_id: this.request.correlation_id,
            team: this.request.team,
            command: this.request.command,
            source: this.request.source,
            destinations: [source],
            status,
            skill: this.request.skill,
        };
        return this.sendResponse(response);
    }
}
exports.PubSubCommandMessageClient = PubSubCommandMessageClient;
class PubSubEventMessageClient extends AbstractPubSubMessageClient {
    constructor(request, graphClient, teamId, teamName, operationName, correlationId) {
        super(request, correlationId, {
            id: teamId,
            name: teamName,
        }, undefined, teamId, graphClient);
        this.request = request;
        this.graphClient = graphClient;
        this.teamId = teamId;
        this.teamName = teamName;
        this.operationName = operationName;
        this.correlationId = correlationId;
    }
    async doSend(msg, destinations, options = {}) {
        return super.doSend(msg, destinations, options);
    }
    async publish(status) {
        const response = {
            api_version: "1",
            correlation_id: this.correlationId,
            team: {
                id: this.teamId,
                name: this.teamName,
            },
            event: this.operationName,
            status,
            skill: this.request.skill,
        };
        return this.sendResponse(response);
    }
}
exports.PubSubEventMessageClient = PubSubEventMessageClient;
class PubSubWebhookMessageClient extends AbstractPubSubMessageClient {
    constructor(request, graphClient) {
        super(request, request.correlation_id, {
            id: request.team_id,
            name: undefined,
        }, undefined, request.team_id, graphClient);
        this.request = request;
        this.graphClient = graphClient;
    }
    async doSend(msg, destinations, options = {}) {
        return super.doSend(msg, destinations, options);
    }
    async publish(status) {
        const response = {
            api_version: "1",
            correlation_id: this.request.correlation_id,
            team: {
                id: this.request.team_id,
                name: undefined,
            },
            status,
            skill: this.request.skill,
        };
        return this.sendResponse(response);
    }
}
exports.PubSubWebhookMessageClient = PubSubWebhookMessageClient;
function prepareStatus(status, context) {
    if (status instanceof Error) {
        return {
            code: 1,
            reason: `Error invoking ${context.skill.namespace}/${context.skill.name}`,
        };
    }
    else {
        const reason = `${(status === null || status === void 0 ? void 0 : status.code) === 0 ? "Successfully" : "Unsuccessfully"} invoked ${context.skill.namespace}/${context.skill.name}@${context.name}`;
        return {
            visibility: status === null || status === void 0 ? void 0 : status.visibility,
            code: (status === null || status === void 0 ? void 0 : status.code) || 0,
            reason: (status === null || status === void 0 ? void 0 : status.reason) || reason,
        };
    }
}
exports.prepareStatus = prepareStatus;
//# sourceMappingURL=message.js.map