"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundle = exports.registerWebhook = exports.registerEvent = exports.registerCommand = void 0;
const function_1 = require("./function");
const map_1 = require("./map");
const payload_1 = require("./payload");
const payload_resolve_1 = require("./payload_resolve");
const HandlerRegistry = {
    events: {},
    commands: {},
    webhooks: {},
};
/**
 * Register a command handler with a certain name
 */
function registerCommand(name, loader) {
    HandlerRegistry.commands[name] = loader;
}
exports.registerCommand = registerCommand;
/**
 * Register a event handler with a certain name
 */
function registerEvent(name, loader) {
    HandlerRegistry.events[name] = loader;
}
exports.registerEvent = registerEvent;
/**
 * Register a webhook handler with a certain name
 */
function registerWebhook(name, loader) {
    HandlerRegistry.webhooks[name] = loader;
}
exports.registerWebhook = registerWebhook;
const bundle = async (pubSubEvent, context) => {
    const payload = await payload_resolve_1.resolvePayload(pubSubEvent);
    if (payload_1.isEventIncoming(payload)) {
        return function_1.processEvent(payload, context, async () => {
            const loader = HandlerRegistry.events[payload.extensions.operationName];
            if (loader) {
                return loader();
            }
            else {
                throw new Error(`Event handler with name '${payload.extensions.operationName}' not registered`);
            }
        });
    }
    else if (payload_1.isSubscriptionIncoming(payload)) {
        return function_1.processEvent(payload, context, async () => {
            const loader = HandlerRegistry.events[payload.subscription.name];
            if (loader) {
                return map_1.wrapEventHandler(await loader());
            }
            else {
                throw new Error(`Event handler with name '${payload.subscription.name}' not registered`);
            }
        });
    }
    else if (payload_1.isCommandIncoming(payload)) {
        return function_1.processCommand(payload, context, async () => {
            const loader = HandlerRegistry.commands[payload.command];
            if (loader) {
                return loader();
            }
            else {
                throw new Error(`Command handler with name '${payload.command}' not registered`);
            }
        });
    }
    else if (payload_1.isWebhookIncoming(payload)) {
        return function_1.processWebhook(payload, context, async () => {
            const loader = HandlerRegistry.webhooks[payload.webhook.parameter_name];
            if (loader) {
                return loader();
            }
            else {
                throw new Error(`Command handler with name '${payload.webhook.parameter_name}' not registered`);
            }
        });
    }
};
exports.bundle = bundle;
//# sourceMappingURL=bundle.js.map