"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveParameters = exports.createDatalogClient = void 0;
const edn_data_1 = require("edn-data");
const pRetry = require("p-retry");
const console_1 = require("../log/console");
const map_1 = require("../map");
const retry_1 = require("../retry");
const util_1 = require("../util");
const transact_1 = require("./transact");
class NodeFetchDatalogClient {
    constructor(apiKey, url, workspaceId, correlationId, skill) {
        this.apiKey = apiKey;
        this.url = url;
        this.workspaceId = workspaceId;
        this.correlationId = correlationId;
        this.skill = skill;
    }
    async transact(entities) {
        return transact_1.createTransact(this.workspaceId, this.correlationId, this.skill.id)(entities);
    }
    async query(query, parameters, options = {}) {
        const body = `{
:query

	${resolveParameters(query, parameters)}

${(options === null || options === void 0 ? void 0 : options.tx) ? `:tx-range {:start ${options.tx} }` : ""}
${(options === null || options === void 0 ? void 0 : options.configurationName)
            ? `:skill-ref {:name "${this.skill.name}" :namespace "${this.skill.namespace}" :configuration-name "${options.configurationName}"}`
            : ""}
 
}`;
        const f = (await Promise.resolve().then(() => require("node-fetch"))).default;
        const result = await (await retry_1.retry(async () => {
            var _a, _b;
            try {
                return await f(this.url, {
                    method: "post",
                    body,
                    headers: {
                        "authorization": `bearer ${this.apiKey}`,
                        "content-type": "application/edn",
                    },
                });
            }
            catch (e) {
                // Retry DNS issues
                if (((_a = e.message) === null || _a === void 0 ? void 0 : _a.includes("EAI_AGAIN")) &&
                    ((_b = e.message) === null || _b === void 0 ? void 0 : _b.includes("getaddrinfo"))) {
                    console_1.warn("Retrying Datalog operation due to DNS lookup failure");
                    throw e;
                }
                else {
                    throw new pRetry.AbortError(e);
                }
            }
        })).text();
        if (options.mode === "raw") {
            return result;
        }
        else {
            const parsed = edn_data_1.parseEDNString(result, {
                mapAs: "object",
                keywordAs: "string",
            });
            if (options.mode === "obj") {
                return util_1.toArray(parsed[0]);
            }
            if (options.tx) {
                return util_1.toArray(parsed[0].result).map(map_1.mapSubscription);
            }
            else {
                return util_1.toArray(parsed).map(map_1.mapSubscription);
            }
        }
    }
}
function createDatalogClient(apiKey, wid, correlationId, skill, endpoint = process.env.ATOMIST_DATALOG_ENDPOINT ||
    "https://api.atomist.com/datalog") {
    const url = `${endpoint}/team/${wid}`;
    return new NodeFetchDatalogClient(apiKey, url, wid, correlationId, skill);
}
exports.createDatalogClient = createDatalogClient;
function resolveParameters(query, parameters = {}) {
    let newQuery = query;
    for (const key of Object.keys(parameters)) {
        const value = parameters[key];
        newQuery = newQuery.replace(new RegExp(`\\?${key}`, "g"), typeof value === "string" ? `"${value}"` : value);
    }
    return newQuery;
}
exports.resolveParameters = resolveParameters;
//# sourceMappingURL=client.js.map