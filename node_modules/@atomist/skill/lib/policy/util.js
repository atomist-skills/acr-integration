"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.createPolicyRun = void 0;
const operation_1 = require("../github/operation");
const util_1 = require("../handler/util");
const status_1 = require("../status");
const util_2 = require("../util");
const badge_1 = require("./badge");
const result_1 = require("./result");
function createPolicyRun(options) {
    return async (ctx) => {
        if (!ctx.chain.id) {
            return status_1.failure("'id' missing in chain. Make sure to include 'createRef' in handler chain");
        }
        const optsToUse = typeof options === "function" ? options(ctx) : options;
        ctx.chain.policy = await result_1.pending(ctx, Object.assign({ sha: ctx.chain.id.sha }, optsToUse));
        return undefined;
    };
}
exports.createPolicyRun = createPolicyRun;
function createDetails(options) {
    return async (ctx) => {
        ctx.chain.details = options(ctx);
    };
}
function handler(parameters) {
    return util_1.chain(async (ctx) => {
        if (parameters.when) {
            return parameters.when(ctx);
        }
        return undefined;
    }, util_1.createRef(parameters.id), async (ctx) => {
        var _a;
        if (parameters.clone) {
            try {
                if (typeof parameters.clone === "function") {
                    await util_1.cloneRef(parameters.clone(ctx))(ctx);
                }
                else {
                    await util_1.cloneRef()(ctx);
                }
            }
            catch (e) {
                return status_1.success(`Failed to clone ${ctx.chain.id.owner}/${ctx.chain.id.repo}#${((_a = ctx.chain.id.sha) === null || _a === void 0 ? void 0 : _a.slice(0, 7)) || ctx.chain.id.branch}`).hidden();
            }
        }
        return undefined;
    }, createDetails(parameters.details), async (ctx) => {
        const app = util_2.isStaging() ? "atomista" : "atomist";
        const tx = ctx.trigger.subscription.tx;
        const checks = (await operation_1.api(ctx.chain.id).checks.listForRef({
            owner: ctx.chain.id.owner,
            repo: ctx.chain.id.repo,
            ref: ctx.chain.id.sha,
            check_name: ctx.chain.details.name,
            filter: "latest",
        })).data;
        if (checks.check_runs
            .filter(c => c.app.slug === app)
            .filter(c => !isNaN(+c.external_id))
            .some(c => +c.external_id > tx)) {
            return status_1.success("Skipping execution of outdated subscription result").hidden();
        }
        return undefined;
    }, util_1.createCheck(async (ctx) => ({
        name: ctx.chain.details.name,
        title: ctx.chain.details.title,
        body: `${await badge_1.markdownLink({
            sha: ctx.chain.id.sha,
            workspace: ctx.workspaceId,
            name: ctx.chain.details.name,
            title: ctx.chain.details.title,
            state: result_1.ResultEntityState.Pending,
        })}\n\n${ctx.chain.details.body ? `\n\n${ctx.chain.details.body}` : ""}`,
    })), createPolicyRun((ctx) => ({
        name: ctx.chain.details.name,
        title: ctx.chain.details.title,
    })), async (ctx) => {
        const result = await parameters.execute(ctx);
        let conclusion;
        switch (result.state) {
            case result_1.ResultEntityState.Success:
                conclusion = "success";
                break;
            case result_1.ResultEntityState.ActionRequired:
                conclusion = "action_required";
                break;
            case result_1.ResultEntityState.Failure:
                conclusion = "failure";
                break;
            case result_1.ResultEntityState.Neutral:
                conclusion = "neutral";
                break;
        }
        const body = `${await badge_1.markdownLink({
            sha: ctx.chain.id.sha,
            workspace: ctx.workspaceId,
            name: ctx.chain.details.name,
            title: ctx.chain.details.title,
            state: result.state,
            severity: result.severity,
        })}${result.body ? `\n\n${result.body}` : ""}`;
        await ctx.chain.check.update({
            conclusion,
            body,
            annotations: result.annotations,
            actions: result.actions,
        });
        switch (result.state) {
            case result_1.ResultEntityState.Success:
                await ctx.chain.policy.success(result.body);
                break;
            case result_1.ResultEntityState.ActionRequired:
                await ctx.chain.policy.actionRequired(result.severity, result.body);
                break;
            case result_1.ResultEntityState.Failure:
                await ctx.chain.policy.failed(result.severity, result.body);
                break;
            case result_1.ResultEntityState.Neutral:
                await ctx.chain.policy.neutral(result.body);
                break;
        }
        return result.status;
    });
}
exports.handler = handler;
//# sourceMappingURL=util.js.map