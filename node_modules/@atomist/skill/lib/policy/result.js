"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.pending = exports.toSeverity = exports.ResultEntitySeverity = exports.toState = exports.ResultEntityState = void 0;
const util_1 = require("../datalog/util");
var ResultEntityState;
(function (ResultEntityState) {
    ResultEntityState["Pending"] = ":policy.result.state/PENDING";
    ResultEntityState["Success"] = ":policy.result.state/SUCCESS";
    ResultEntityState["Failure"] = ":policy.result.state/FAILURE";
    ResultEntityState["ActionRequired"] = ":policy.result.state/ACTION_REQUIRED";
    ResultEntityState["Neutral"] = ":policy.result.state/NEUTRAL";
})(ResultEntityState = exports.ResultEntityState || (exports.ResultEntityState = {}));
function toState(state) {
    for (const key of Object.keys(ResultEntityState)) {
        if (`:policy.result.state/${state.toUpperCase()}` ===
            ResultEntityState[key]) {
            return ResultEntityState[key];
        }
    }
    return undefined;
}
exports.toState = toState;
var ResultEntitySeverity;
(function (ResultEntitySeverity) {
    ResultEntitySeverity["Critial"] = ":policy.result.severity/CRITICAL";
    ResultEntitySeverity["High"] = ":policy.result.severity/HIGH";
    ResultEntitySeverity["Medium"] = ":policy.result.severity/MEDIUM";
    ResultEntitySeverity["Low"] = ":policy.result.severity/LOW";
    ResultEntitySeverity["Minimum"] = ":policy.result.severity/MINIMUM";
})(ResultEntitySeverity = exports.ResultEntitySeverity || (exports.ResultEntitySeverity = {}));
function toSeverity(severity) {
    for (const key of Object.keys(ResultEntitySeverity)) {
        if (`:policy.result.severity/${severity.toUpperCase()}` ===
            ResultEntitySeverity[key]) {
            return ResultEntitySeverity[key];
        }
    }
    return undefined;
}
exports.toSeverity = toSeverity;
async function pending(ctx, parameters) {
    let terminated = false;
    const ownerEntity = util_1.entity("policy.result/owner", {
        name: ctx.skill.name,
        namespace: ctx.skill.namespace,
        version: ctx.skill.version,
    });
    let resultEntity = util_1.entity("policy/result", {
        sha: parameters.sha,
        name: parameters.name || ctx.skill.name,
        title: parameters.title,
        state: ResultEntityState.Pending,
        createdAt: new Date(),
        lastUpdated: new Date(),
        managedBy: util_1.entityRef(ownerEntity),
    });
    await ctx.datalog.transact([ownerEntity, resultEntity]);
    const update = (state) => async (message, severity) => {
        resultEntity = util_1.entity("policy/result", Object.assign(Object.assign({}, resultEntity), { sha: parameters.sha, name: parameters.name || ctx.skill.name, title: parameters.title, message,
            state,
            severity, lastUpdated: new Date() }));
        await ctx.datalog.transact([ownerEntity, resultEntity]);
        terminated = true;
    };
    ctx.onComplete(async () => {
        if (!terminated) {
            await update(ResultEntityState.Failure)("Policy failed to complete", ResultEntitySeverity.High);
        }
    });
    return {
        failed: (severity, msg) => update(ResultEntityState.Failure)(msg, severity),
        actionRequired: (severity, msg) => update(ResultEntityState.ActionRequired)(msg, severity),
        neutral: msg => update(ResultEntityState.Neutral)(msg),
        success: msg => update(ResultEntityState.Success)(msg),
    };
}
exports.pending = pending;
//# sourceMappingURL=result.js.map