"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.headChangedFiles = exports.stashPop = exports.stash = exports.changedFiles = exports.setUserConfig = exports.hasBranch = exports.createBranch = exports.push = exports.revert = exports.checkout = exports.commit = exports.editCommit = exports.ensureBranch = exports.persistChanges = exports.retryOptions = exports.status = exports.init = void 0;
const pRetry = require("p-retry");
const child_process_1 = require("../child_process");
const index_1 = require("../log/index");
const util_1 = require("../project/util");
const status_1 = require("./status");
const forOwn = require("lodash.forown");
/** Default name of default git remote. */
const origin = "origin";
/**
 * Init a new Git repository
 */
async function init(projectOrCwd) {
    await child_process_1.execPromise("git", ["init"], { cwd: util_1.cwd(projectOrCwd) });
}
exports.init = init;
/**
 * Return status information about a Git repository
 */
async function status(projectOrCwd) {
    return status_1.runStatusIn(util_1.cwd(projectOrCwd));
}
exports.status = status;
/** Default retry options for git operations. */
exports.retryOptions = {
    retries: 5,
    factor: 2,
    minTimeout: 500,
    maxTimeout: 5000,
    randomize: true,
};
/**
 * Execute editors on a project, commit, and then push the commit(s) to
 * the remote. Effort is made to ensure success. The git status should
 * be clean, i.e., have no uncommited changes, when calling this
 * function.
 */
async function persistChanges(args) {
    if (!args.editors || args.editors.length < 1) {
        throw new Error(`No project editors provided`);
    }
    const dir = util_1.cwd(args.project);
    const stat = await status(dir);
    if (!stat.isClean) {
        throw new Error(`Git project is not clean`);
    }
    const branch = args.branch;
    await ensureBranch(args.project, branch, true);
    await pRetry(async () => {
        await child_process_1.execPromise("git", ["fetch", origin, branch], { cwd: dir });
        await child_process_1.execPromise("git", ["reset", "--hard", `${origin}/${branch}`], {
            cwd: dir,
        });
        await editCommit(args.project, args.editors, args.message, args.author);
        await push(args.project, Object.assign(Object.assign({}, args.options), { branch }));
    }, exports.retryOptions);
}
exports.persistChanges = persistChanges;
/** [[_ensureBranch]] with retry. */
async function ensureBranch(projectOrCwd, branch, sync) {
    await pRetry(async () => _ensureBranch(projectOrCwd, branch, sync), exports.retryOptions);
}
exports.ensureBranch = ensureBranch;
/**
 *
 * Ensure a branch exists locally and check it out. The behavior
 * depends on the value of `sync`.
 *
 * If `sync` is `true`, the local branch will be reset to its remote
 * counterpart, if it exists. If the remote branch does not exist,
 * then the local branch, which may have just been created, is pushed
 * to the remote and set as the upstream.
 *
 * If `sync` is `false` and the branch exists locally, use it. If
 * branch does not exist locally, create it. Any existing remote
 * branch is ignored.
 *
 * Since most skills clone only a single branch, this function updates
 * the remote.origin.fetch configuration to map all remote branches to
 * local branches, instead of just the cloned branch.
 *
 * @param projectOrCwd local git repository clone
 * @param branch branch to ensure exists
 * @param sync ensure local branch and its remote are in sync
 */
async function _ensureBranch(projectOrCwd, branch, sync) {
    const dir = util_1.cwd(projectOrCwd);
    const opts = { cwd: dir };
    await child_process_1.execPromise("git", [
        "config",
        `remote.${origin}.fetch`,
        `+refs/heads/*:refs/remotes/${origin}/*`,
    ], opts);
    const localExists = await hasBranch(dir, branch);
    const fetchResult = await child_process_1.spawnPromise("git", ["fetch", origin, branch], opts);
    const remoteExists = fetchResult.status === 0;
    index_1.debug(`Ensuring branch ${branch}: sync=${sync} ` +
        `localExists=${localExists} remoteExists=${remoteExists}`);
    const checkoutArgs = ["checkout", branch];
    const createArgs = ["checkout", "-b", branch];
    if (sync) {
        if (remoteExists) {
            await child_process_1.execPromise("git", checkoutArgs, opts);
            await child_process_1.execPromise("git", ["reset", "--hard", `${origin}/${branch}`], opts);
        }
        else if (localExists) {
            await child_process_1.execPromise("git", checkoutArgs, opts);
        }
        else {
            await child_process_1.execPromise("git", createArgs, opts);
        }
        await child_process_1.execPromise("git", ["push", "--set-upstream", origin, branch], {
            cwd: dir,
        });
    }
    else {
        if (localExists) {
            await child_process_1.execPromise("git", checkoutArgs, opts);
        }
        else {
            await child_process_1.execPromise("git", createArgs, opts);
        }
    }
}
/**
 * Run a series of project editing functions. If a function returns a
 * string and there are uncommitted changes, the returned string is
 * used as the commit message. If an edit function returns
 * `undefined`, no commit is made prior to running the next edit
 * function. If there are uncommitted changes after all editors are
 * run, they are committed with `message` as the commit message, or a
 * generic commit message if `message` is not provided.
 *
 * @param projectOrCwd project or directory of repository
 * @param editors functions that make changes to the repository
 * @param message commit message to use for uncommitted changes
 * @param author commit author information
 * @return list of changed files, a file may appear more than once if it is
 *         changed by multiple editor functions
 */
async function editCommit(projectOrCwd, editors, message, author) {
    const files = [];
    for (const editor of editors || []) {
        const msg = await editor(projectOrCwd);
        files.push(...(await changedFiles(projectOrCwd)));
        if (msg && !(await status(projectOrCwd)).isClean) {
            await commit(projectOrCwd, msg, author);
        }
    }
    if (!(await status(projectOrCwd)).isClean) {
        const msg = message || `Updates from Atomist skill\n\n[atomist:generated]`;
        await commit(projectOrCwd, msg, author);
    }
    return files;
}
exports.editCommit = editCommit;
/**
 * `git add .` and `git commit -m MESSAGE`
 */
async function commit(projectOrCwd, message, options = {}) {
    const dir = util_1.cwd(projectOrCwd);
    await child_process_1.execPromise("git", ["add", "."], { cwd: dir });
    const botName = "Atomist Bot";
    const botEmail = "bot@atomist.com";
    const env = Object.assign(Object.assign({}, process.env), { GIT_AUTHOR_NAME: botName, GIT_AUTHOR_EMAIL: botEmail, GIT_COMMITTER_NAME: options.name || botName, GIT_COMMITTER_EMAIL: options.email || botEmail });
    await child_process_1.execPromise("git", ["commit", "-m", message, "--no-verify", "--no-gpg-sign"], { cwd: dir, env });
}
exports.commit = commit;
/**
 * Check out a git ref. If checking out a commit SHA, the repo will be
 * in a detached head state. The ref must already exist.
 */
async function checkout(projectOrCwd, ref) {
    await child_process_1.execPromise("git", ["checkout", ref, "--"], {
        cwd: util_1.cwd(projectOrCwd),
    });
}
exports.checkout = checkout;
/**
 * Revert all changes since last commit
 */
async function revert(projectOrCwd) {
    await child_process_1.execPromise("git", ["clean", "-dfx"], { cwd: util_1.cwd(projectOrCwd) });
    await child_process_1.execPromise("git", ["checkout", "--", "."], {
        cwd: util_1.cwd(projectOrCwd),
    });
}
exports.revert = revert;
/**
 * Push all changes to the remote
 */
async function push(projectOrCwd, options) {
    await pRetry(async () => _push(projectOrCwd, options), exports.retryOptions);
}
exports.push = push;
/** Internal push functionality without retry. See [[push]]. */
async function _push(projectOrCwd, options) {
    const gitPushArgs = ["push"];
    const branch = options === null || options === void 0 ? void 0 : options.branch;
    const dir = util_1.cwd(projectOrCwd);
    forOwn(options, (v, k) => {
        if (k !== "branch") {
            const opt = k.replace(/_/g, "-");
            if (typeof v === "boolean") {
                if (v === false) {
                    gitPushArgs.push(`--no-${opt}`);
                }
                else {
                    gitPushArgs.push(`--${opt}`);
                }
            }
            else if (typeof v === "string") {
                gitPushArgs.push(`--${opt}=${v}`);
            }
        }
    });
    if (branch) {
        gitPushArgs.push("--set-upstream", origin, branch);
    }
    else {
        gitPushArgs.push(origin);
    }
    try {
        await child_process_1.execPromise("git", gitPushArgs, { cwd: dir });
    }
    catch (e) {
        index_1.debug("Push failed. Attempting pull and rebase");
        const fetchArgs = ["fetch", origin];
        if (branch) {
            fetchArgs.push(branch);
        }
        await child_process_1.execPromise("git", fetchArgs, { cwd: dir });
        const rebaseArgs = ["rebase"];
        if (branch) {
            rebaseArgs.push(`${origin}/${branch}`);
        }
        try {
            await child_process_1.execPromise("git", rebaseArgs, { cwd: dir });
        }
        catch (er) {
            index_1.debug("Rebase failed, aborting");
            await child_process_1.execPromise("git", ["rebase", "--abort"], { cwd: dir });
            throw er;
        }
        await child_process_1.execPromise("git", gitPushArgs, { cwd: dir });
    }
}
/**
 * Create branch from current HEAD.
 */
async function createBranch(projectOrCwd, name) {
    await child_process_1.execPromise("git", ["checkout", "-b", name], {
        cwd: util_1.cwd(projectOrCwd),
    });
}
exports.createBranch = createBranch;
/**
 * Check if a branch exists.
 */
async function hasBranch(projectOrCwd, name) {
    const result = await child_process_1.execPromise("git", ["branch", "--list", name], {
        cwd: util_1.cwd(projectOrCwd),
    });
    return result.stdout.replace("*", "").trim() === name;
}
exports.hasBranch = hasBranch;
/** Set git user name and email. */
async function setUserConfig(project, name = "Atomist Bot", email = "bot@atomist.com") {
    await project.exec("git", ["config", "user.name", name]);
    await project.exec("git", ["config", "user.email", email]);
}
exports.setUserConfig = setUserConfig;
/**
 * Return changed files, including untracked file.
 */
async function changedFiles(projectOrCwd) {
    const changedFiles = (await child_process_1.execPromise("git", ["diff", "--name-only"], {
        cwd: util_1.cwd(projectOrCwd),
    })).stdout
        .split("\n")
        .map(f => f.trim())
        .filter(f => !!f && f.length > 0);
    const untrackedFiles = (await child_process_1.execPromise("git", ["ls-files", "--exclude-standard", "--others"], { cwd: util_1.cwd(projectOrCwd) })).stdout
        .split("\n")
        .map(f => f.trim())
        .filter(f => !!f && f.length > 0);
    return [...changedFiles, ...untrackedFiles].sort();
}
exports.changedFiles = changedFiles;
async function stash(projectOrCwd, options) {
    if (options === null || options === void 0 ? void 0 : options.add) {
        await child_process_1.execPromise("git", ["add", "."], { cwd: util_1.cwd(projectOrCwd) });
    }
    await child_process_1.execPromise("git", ["stash"], { cwd: util_1.cwd(projectOrCwd) });
}
exports.stash = stash;
async function stashPop(projectOrCwd) {
    await child_process_1.execPromise("git", ["stash", "pop"], { cwd: util_1.cwd(projectOrCwd) });
}
exports.stashPop = stashPop;
async function headChangedFiles(projectOrCwd) {
    return (await child_process_1.execPromise("git", ["diff", "--name-only", "HEAD~1"], {
        cwd: util_1.cwd(projectOrCwd),
    })).stdout
        .split("\n")
        .map(f => f.trim())
        .filter(f => !!f && f.length > 0);
}
exports.headChangedFiles = headChangedFiles;
//# sourceMappingURL=operation.js.map