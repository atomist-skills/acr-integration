"use strict";
/*
 * Copyright Â© 2020 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineBranch = exports.runStatusIn = exports.isFullyClean = void 0;
const child_process_1 = require("../child_process");
function isFullyClean(gs) {
    return gs.isClean && gs.ignoredChanges.length === 0;
}
exports.isFullyClean = isFullyClean;
async function runStatusIn(baseDir) {
    const branch = await determineBranch(baseDir);
    const upstreamData = await collectUpstream(baseDir, branch);
    const shaData = await collectFullSha(baseDir);
    const cleanlinessData = await collectCleanliness(baseDir);
    const ignoredChangeData = await collectIgnoredChanges(baseDir);
    const detached = await collectDetached(baseDir);
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ branch }, ignoredChangeData), cleanlinessData), shaData), upstreamData), { detached });
}
exports.runStatusIn = runStatusIn;
async function determineBranch(baseDir) {
    const branchNameResult = await child_process_1.execPromise("git", ["rev-parse", "--abbrev-ref", "HEAD"], { cwd: baseDir });
    return branchNameResult.stdout.trim();
}
exports.determineBranch = determineBranch;
async function collectCleanliness(baseDir) {
    const porcelainStatusResult = await child_process_1.execPromise("git", ["status", "--porcelain"], { cwd: baseDir });
    const raw = porcelainStatusResult.stdout;
    return { isClean: raw.length === 0 };
}
async function collectIgnoredChanges(baseDir) {
    const porcelainStatusResult = await child_process_1.execPromise("git", ["status", "--porcelain", "--ignored"], { cwd: baseDir });
    const raw = porcelainStatusResult.stdout;
    const ignored = raw
        .trim()
        .split("\n")
        .filter(s => s.startsWith("!"))
        .map(s => s.substring(3));
    return {
        raw,
        ignoredChanges: ignored,
    };
}
async function collectFullSha(baseDir, commit = "HEAD") {
    const result = await child_process_1.execPromise("git", ["rev-list", "-1", commit, "--"], {
        cwd: baseDir,
    });
    return {
        sha: result.stdout.trim(),
    };
}
async function collectUpstream(baseDir, branch) {
    const branchArgs = [
        "for-each-ref",
        "--format",
        "%(upstream:short) %(upstream:trackshort)",
        `refs/heads/${branch}`,
    ];
    const branchResult = await child_process_1.execPromise("git", branchArgs, { cwd: baseDir });
    const branchResultParts = branchResult.stdout.trim().split(" ");
    const upstream = branchResultParts.length > 0
        ? {
            branch: branchResultParts[0],
            inSync: branchResultParts[1] === "=",
        }
        : undefined;
    return { upstream };
}
async function collectDetached(baseDir) {
    const statusResult = await child_process_1.execPromise("git", ["status"], { cwd: baseDir });
    return statusResult.stdout.includes("HEAD detached at ");
}
//# sourceMappingURL=status.js.map