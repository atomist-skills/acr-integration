import { Project } from "../project/project";
import { Status } from "./status";
/**
 * Git push options.  See git-push(1) for more information.
 */
export interface GitPushOptions {
    follow_tags?: boolean;
    force?: boolean;
    force_with_lease?: boolean | string;
    quiet?: boolean;
    verbose?: boolean;
    branch?: string;
}
/**
 * Init a new Git repository
 */
export declare function init(projectOrCwd: Project | string): Promise<void>;
/**
 * Return status information about a Git repository
 */
export declare function status(projectOrCwd: Project | string): Promise<Status>;
/** Default retry options for git operations. */
export declare const retryOptions: {
    retries: number;
    factor: number;
    minTimeout: number;
    maxTimeout: number;
    randomize: boolean;
};
export declare type CommitEditor = (pd: Project | string) => Promise<string | undefined>;
/** Argument to [[persistChanges]]. */
export interface PersistChangesArgs {
    /**
     * Project containing or path to cloned git repository.
     */
    project: Project | string;
    /**
     * Branch to commit to. If it does not exist, it is created. See
     * [[ensureBranch]] for details.
     */
    branch: string;
    /**
     * Functions that make changes to the project. If a function
     * returns a string, that string is used as the commit message for
     * the changes the function made. If a function returns
     * `undefined`, committing is deferred until a subsequent function
     * returns a string. If there are uncommitted changes when all
     * editors have been run, [[message]] is used as the commit
     * message for the remaining changes.
     */
    editors: CommitEditor[];
    /**
     * If there are uncommitted changes after all [[editors]] have
     * run, this is used as the commit message. If [[message]] is not
     * provided and there are changes to commit, a default message is
     * used.
     */
    message?: string;
    /** Git commit author information. */
    author?: {
        login?: string;
        email?: string;
    };
    /** Options to supply to `git push`. */
    options?: GitPushOptions;
}
/**
 * Execute editors on a project, commit, and then push the commit(s) to
 * the remote. Effort is made to ensure success. The git status should
 * be clean, i.e., have no uncommited changes, when calling this
 * function.
 */
export declare function persistChanges(args: PersistChangesArgs): Promise<void>;
/** [[_ensureBranch]] with retry. */
export declare function ensureBranch(projectOrCwd: Project | string, branch: string, sync: boolean): Promise<void>;
/**
 * Run a series of project editing functions. If a function returns a
 * string and there are uncommitted changes, the returned string is
 * used as the commit message. If an edit function returns
 * `undefined`, no commit is made prior to running the next edit
 * function. If there are uncommitted changes after all editors are
 * run, they are committed with `message` as the commit message, or a
 * generic commit message if `message` is not provided.
 *
 * @param projectOrCwd project or directory of repository
 * @param editors functions that make changes to the repository
 * @param message commit message to use for uncommitted changes
 * @param author commit author information
 * @return list of changed files, a file may appear more than once if it is
 *         changed by multiple editor functions
 */
export declare function editCommit(projectOrCwd: Project | string, editors: CommitEditor[], message?: string, author?: {
    login?: string;
    email?: string;
}): Promise<string[]>;
/**
 * `git add .` and `git commit -m MESSAGE`
 */
export declare function commit(projectOrCwd: Project | string, message: string, options?: {
    name?: string;
    email?: string;
}): Promise<void>;
/**
 * Check out a git ref. If checking out a commit SHA, the repo will be
 * in a detached head state. The ref must already exist.
 */
export declare function checkout(projectOrCwd: Project | string, ref: string): Promise<void>;
/**
 * Revert all changes since last commit
 */
export declare function revert(projectOrCwd: Project | string): Promise<void>;
/**
 * Push all changes to the remote
 */
export declare function push(projectOrCwd: Project | string, options?: GitPushOptions): Promise<void>;
/**
 * Create branch from current HEAD.
 */
export declare function createBranch(projectOrCwd: Project | string, name: string): Promise<void>;
/**
 * Check if a branch exists.
 */
export declare function hasBranch(projectOrCwd: Project | string, name: string): Promise<boolean>;
/** Set git user name and email. */
export declare function setUserConfig(project: Project, name?: string, email?: string): Promise<void>;
/**
 * Return changed files, including untracked file.
 */
export declare function changedFiles(projectOrCwd: Project | string): Promise<string[]>;
export declare function stash(projectOrCwd: Project | string, options?: {
    add: boolean;
}): Promise<void>;
export declare function stashPop(projectOrCwd: Project | string): Promise<void>;
export declare function headChangedFiles(projectOrCwd: Project | string): Promise<string[]>;
//# sourceMappingURL=operation.d.ts.map