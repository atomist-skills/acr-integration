"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createYamlSkillInput = exports.defaults = void 0;
const edn_data_1 = require("edn-data");
const fs = require("fs-extra");
const yaml = require("js-yaml");
const path = require("path");
const child_process_1 = require("../child_process");
const skill_1 = require("../definition/skill");
const named_1 = require("../definition/subscription/named");
const log_1 = require("../log");
const util_1 = require("../project/util");
const skill_input_1 = require("./skill_input");
const merge = require("lodash.merge");
async function defaults(cwd) {
    const originUrl = await child_process_1.spawnPromise("git", ["config", "--get", "remote.origin.url"], { cwd });
    const giturl = (await Promise.resolve().then(() => require("git-url-parse")))(originUrl.stdout.trim());
    let description = `Atomist Skill registered from ${giturl.owner}/${giturl.name}`;
    let longDescription = description;
    let readme = description;
    if (await fs.pathExists(path.join(cwd, "README.md"))) {
        const readmeContent = (await fs.readFile(path.join(cwd, "README.md"))).toString();
        const descriptionRegexp = /<!---atomist-skill-description:start--->([\s\S]*)<!---atomist-skill-description:end--->/gm;
        const descriptionMatch = descriptionRegexp.exec(readmeContent);
        if (descriptionMatch) {
            description = descriptionMatch[1].trim();
            longDescription = description;
        }
        const longDescriptionRegexp = /<!---atomist-skill-long_description:start--->([\s\S]*)<!---atomist-skill-long_description:end--->/gm;
        const longDescriptionMatch = longDescriptionRegexp.exec(readmeContent);
        if (longDescriptionMatch) {
            longDescription = longDescriptionMatch[1].trim();
        }
        const readmeRegexp = /<!---atomist-skill-readme:start--->([\s\S]*)<!---atomist-skill-readme:end--->/gm;
        const readmeMatch = readmeRegexp.exec(readmeContent);
        if (readmeMatch) {
            readme = readmeMatch[1].trim();
        }
    }
    let iconUrl = `https://github.com/${giturl.owner}.png`;
    const icons = await util_1.globFiles(cwd, "**/icon.svg");
    if (icons.length > 0) {
        const iconFile = (await fs.readFile(path.join(cwd, icons[0]))).toString("base64");
        iconUrl = `data:image/svg+xml;base64,${iconFile}`;
    }
    return {
        name: giturl.name,
        namespace: giturl.owner === "atomist-skills" ? "atomist" : giturl.owner,
        displayName: giturl.name,
        author: giturl.owner === "atomist-skills" ? "Atomist" : giturl.owner,
        description,
        longDescription,
        readme,
        iconUrl,
        homepageUrl: `https://github.com/${giturl.owner}/${giturl.name}`,
        license: "Apache-2.0",
    };
}
exports.defaults = defaults;
async function createYamlSkillInput(cwd, artifacts) {
    var _a, _b, _c;
    log_1.info(`Generating skill metadata...`);
    let is = await defaults(cwd);
    if (await fs.pathExists(path.join(cwd, "package.json"))) {
        const pj = skill_1.packageJson(path.join(cwd, "package.json"));
        is = merge({}, is, pj);
    }
    if (await fs.pathExists(path.join(cwd, "skill.yaml"))) {
        const doc = yaml.load((await fs.readFile(path.join(cwd, "skill.yaml"))).toString());
        is = merge({}, is, doc.skill ? doc.skill : doc);
    }
    const rc = skill_input_1.content(cwd);
    const subscriptions = [];
    for (const subscription of is.subscriptions || [
        "file://**/graphql/subscription/*.graphql",
    ]) {
        const subs = (await rc(subscription)).map(s => s
            .replace(/\$\{namespace\}/g, is.namespace)
            .replace(/\$\{name\}/g, is.name));
        subscriptions.push(...subs);
    }
    const datalogSubscriptions = [...(is.datalogSubscriptions || [])];
    datalogSubscriptions.push(...(await util_1.withGlobMatches(cwd, "**/datalog/subscription/*.edn", async (file) => {
        const filePath = path.join(cwd, file);
        const fileName = path.basename(filePath);
        const extName = path.extname(fileName);
        return {
            query: (await fs.readFile(path.join(cwd, file))).toString(),
            name: fileName.replace(extName, ""),
        };
    })));
    datalogSubscriptions.forEach(dl => {
        if (dl.query.startsWith("@")) {
            dl.query = named_1.namedDatalog(dl.query);
        }
    });
    const schemata = [...(is.schemata || [])];
    if (schemata.length === 0) {
        schemata.push(...(await util_1.withGlobMatches(cwd, "**/datalog/schema/*.{json,edn}", async (file) => {
            const filePath = path.join(cwd, file);
            const fileName = path.basename(filePath);
            const extName = path.extname(fileName);
            let schema = (await fs.readFile(path.join(cwd, file))).toString();
            if (file.endsWith(".json")) {
                schema = edn_data_1.toEDNStringFromSimpleObject(JSON.parse(schema));
            }
            return {
                schema,
                name: fileName.replace(extName, ""),
            };
        })));
    }
    const y = Object.assign(Object.assign({}, is), { readme: is.readme
            ? Buffer.from(is.readme).toString("base64")
            : undefined, subscriptions,
        datalogSubscriptions,
        schemata });
    if (!y.longDescription) {
        y.longDescription = y.description;
    }
    if (artifacts) {
        if (!((_a = y.artifacts) === null || _a === void 0 ? void 0 : _a.docker)) {
            const gcf = (_c = (_b = y.artifacts) === null || _b === void 0 ? void 0 : _b.gcf) === null || _c === void 0 ? void 0 : _c[0];
            y.artifacts = {
                gcf: [
                    {
                        entryPoint: (gcf === null || gcf === void 0 ? void 0 : gcf.entryPoint) || "entryPoint",
                        memory: (gcf === null || gcf === void 0 ? void 0 : gcf.memory) || 256,
                        timeout: (gcf === null || gcf === void 0 ? void 0 : gcf.timeout) || 60,
                        runtime: (gcf === null || gcf === void 0 ? void 0 : gcf.runtime) || skill_input_1.AtomistSkillRuntime.Nodejs14,
                        name: "gcf",
                        url: undefined,
                    },
                ],
            };
        }
    }
    else {
        delete y.artifacts;
    }
    return y;
}
exports.createYamlSkillInput = createYamlSkillInput;
//# sourceMappingURL=skill_container.js.map