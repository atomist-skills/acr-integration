"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.apiKey = exports.wid = exports.registerSkill = void 0;
const fs = require("fs-extra");
const yaml = require("js-yaml");
const os = require("os");
const path = require("path");
const semver = require("semver");
const child_process_1 = require("../child_process");
const git = require("../git");
const graphql_1 = require("../graphql");
const log_1 = require("../log");
const provider_1 = require("../storage/provider");
async function registerSkill(cwd, workspaceId, version, verbose) {
    var _a, _b, _c;
    if (!verbose) {
        process.env.ATOMIST_LOG_LEVEL = "info";
    }
    log_1.info("Registering skill...");
    const w = await wid(workspaceId);
    const client = graphql_1.createGraphQLClient(await apiKey(), w);
    const originUrl = await child_process_1.spawnPromise("git", ["config", "--get", "remote.origin.url"], { cwd });
    const branchName = await child_process_1.spawnPromise("git", ["rev-parse", "--abbrev-ref", "HEAD"], { cwd });
    const giturl = (await Promise.resolve().then(() => require("git-url-parse")))(originUrl.stdout.trim());
    const status = await git.status(cwd);
    if (!status.isClean) {
        throw new Error(`Repository contains uncommitted changes. Please commit before running this command.`);
    }
    const storage = new provider_1.GoogleCloudStorageProvider(`gs://${w.toLowerCase()}-workspace-storage`);
    const key = `skills/${w}/${giturl.owner}/${giturl.name}`;
    const url = `gs://${w.toLowerCase()}-workspace-storage/${key}/${status.sha}.zip`;
    const ids = await loadRepoAndBranch(client, {
        owner: giturl.owner,
        name: giturl.name,
        branch: branchName.stdout.trim(),
    });
    const content = (await fs.readFile(path.join(cwd, ".atomist", "skill.yaml"))).toString();
    const atomistYaml = yaml.load(content);
    if ((_c = (_b = (_a = atomistYaml === null || atomistYaml === void 0 ? void 0 : atomistYaml.skill) === null || _a === void 0 ? void 0 : _a.artifacts) === null || _b === void 0 ? void 0 : _b.gcf) === null || _c === void 0 ? void 0 : _c[0]) {
        atomistYaml.skill.artifacts.gcf[0].url = url;
    }
    if (version) {
        atomistYaml.skill.version = version;
    }
    else {
        const q = await qualifier(client, {
            owner: giturl.owner,
            name: giturl.name,
        });
        const latestTagOutput = await child_process_1.spawnPromise("git", ["describe", "--tags", "--abbrev=0"], { cwd });
        let latestTag = "0.1.0";
        if (latestTagOutput.status === 0) {
            latestTag = latestTagOutput.stdout.trim();
        }
        atomistYaml.skill.version = `${semver.major(latestTag)}.${semver.minor(latestTag)}.${semver.patch(latestTag)}-${q}`;
    }
    atomistYaml.skill.branchId = ids.branchId;
    atomistYaml.skill.repoId = ids.repoId;
    atomistYaml.skill.commitSha = status.sha;
    await fs.writeFile(path.join(cwd, ".atomist", "skill.yaml"), yaml.dump(atomistYaml, { skipInvalid: true }));
    if (await fs.pathExists(path.join(cwd, ".atomist", "skill.zip"))) {
        await storage.store(`${key}/${status.sha}.zip`, path.join(cwd, ".atomist", "skill.zip"));
    }
    await storage.store(`${key}/${status.sha}.yaml`, path.join(cwd, ".atomist", "skill.yaml"));
    await register(client, atomistYaml.skill);
    await child_process_1.spawnPromise("git", [
        "tag",
        "-a",
        atomistYaml.skill.version,
        "-m",
        `Registered skill with version ${atomistYaml.skill.version}`,
    ], { cwd });
    log_1.info(`Registered skill '${atomistYaml.skill.namespace}/${atomistYaml.skill.name}' with version '${atomistYaml.skill.version}'`);
}
exports.registerSkill = registerSkill;
const BranchQuery = `query BranchForName($name: String!, $owner: String!, $branch: String!) {
  Branch(name: $branch) {
    id
    repo(name: $name, owner: $owner) @required {
      id
    }
  }
}
`;
async function loadRepoAndBranch(client, branch) {
    const result = await client.query(BranchQuery, branch);
    return {
        repoId: result.Branch[0].repo.id,
        branchId: result.Branch[0].id,
    };
}
const BuildQuery = `query BuildIdentifierForRepo(
  $owner: String!
  $name: String!
) {
  SdmBuildIdentifier {
    identifier
    id
    repo(name: [$name], owner: [$owner]) @required {
      name
      owner
      providerId
    }
  }
}
`;
const BuildMutation = `mutation StoreBuildIdentifierForRepo($identifier: String!, $name: String!, $owner: String!, $providerId: String!) {
    ingestCustomSdmBuildIdentifier(value: {identifier: $identifier, repo: {name: $name, owner: $owner, providerId: $providerId}})
}
`;
async function qualifier(client, repo) {
    var _a, _b, _c;
    const bi = await client.query(BuildQuery, repo);
    const count = (+((_a = bi === null || bi === void 0 ? void 0 : bi.SdmBuildIdentifier[0]) === null || _a === void 0 ? void 0 : _a.identifier) || 0) + 1;
    await client.mutate(BuildMutation, {
        providerId: (_c = (_b = bi === null || bi === void 0 ? void 0 : bi.SdmBuildIdentifier[0]) === null || _b === void 0 ? void 0 : _b.repo) === null || _c === void 0 ? void 0 : _c.providerId,
        name: repo.name,
        owner: repo.owner,
        identifier: count.toString(),
    });
    return count.toString();
}
const RegisterSkillMutation = `mutation RegisterSkill($skill: AtomistSkillInput!) {
    registerSkill(skill: $skill) {
		namespace
		name
		version
    }
}
`;
async function register(client, skill) {
    await client.mutate(RegisterSkillMutation, {
        skill,
    });
}
async function wid(workspaceId) {
    let w = workspaceId || process.env.ATOMIST_WORKSPACE_ID;
    if (!w) {
        const cfgPath = path.join(os.homedir(), ".atomist", "client.config.json");
        if (await fs.pathExists(cfgPath)) {
            const cfg = await fs.readJson(cfgPath);
            w = cfg.workspaceIds[0];
        }
    }
    if (!w) {
        log_1.error(`No workspace id provided. Please pass --workspace or set 'ATOMIST_WORKSPACE_ID'.`);
    }
    return w;
}
exports.wid = wid;
async function apiKey(key) {
    let apiKey = key || process.env.ATOMIST_API_KEY;
    if (!apiKey) {
        const cfgPath = path.join(os.homedir(), ".atomist", "client.config.json");
        if (await fs.pathExists(cfgPath)) {
            const cfg = await fs.readJson(cfgPath);
            apiKey = cfg.apiKey;
        }
    }
    if (!apiKey) {
        log_1.error(`No API key provided. Please set 'ATOMIST_API_KEY'.`);
    }
    return apiKey;
}
exports.apiKey = apiKey;
//# sourceMappingURL=skill_register.js.map