"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.icon = exports.content = exports.writeSkillYaml = exports.generateSkill = exports.validateSkillInput = exports.createJavaScriptSkillInput = exports.AtomistSkillTechnology = exports.AtomistSkillStringParameterLineStyle = exports.AtomistSkillParameterVisiblity = exports.AtomistSkillEventDispatchStyle = exports.AtomistSkillCategoryKey = exports.AtomistSkillRuntime = void 0;
const edn_data_1 = require("edn-data");
const fs = require("fs-extra");
const path = require("path");
const named_1 = require("../definition/subscription/named");
const log_1 = require("../log");
const util_1 = require("../project/util");
const util_2 = require("../util");
const skill_container_1 = require("./skill_container");
const map = require("lodash.map");
const merge = require("lodash.merge");
var AtomistSkillRuntime;
(function (AtomistSkillRuntime) {
    AtomistSkillRuntime["Nodejs10"] = "nodejs10";
    AtomistSkillRuntime["Nodejs12"] = "nodejs12";
    AtomistSkillRuntime["Nodejs14"] = "nodejs14";
    AtomistSkillRuntime["Python37"] = "python37";
    AtomistSkillRuntime["Go113"] = "go113";
})(AtomistSkillRuntime = exports.AtomistSkillRuntime || (exports.AtomistSkillRuntime = {}));
var AtomistSkillCategoryKey;
(function (AtomistSkillCategoryKey) {
    AtomistSkillCategoryKey["Chat"] = "CHAT";
    AtomistSkillCategoryKey["CodeMaintenance"] = "CODE_MAINTENANCE";
    AtomistSkillCategoryKey["DevOps"] = "DEVOPS";
    AtomistSkillCategoryKey["DevSecOps"] = "DEVSECOPS";
    AtomistSkillCategoryKey["RepoManagement"] = "REPO_MANAGEMENT";
    AtomistSkillCategoryKey["Security"] = "SECURITY";
})(AtomistSkillCategoryKey = exports.AtomistSkillCategoryKey || (exports.AtomistSkillCategoryKey = {}));
var AtomistSkillEventDispatchStyle;
(function (AtomistSkillEventDispatchStyle) {
    AtomistSkillEventDispatchStyle["Single"] = "single";
    AtomistSkillEventDispatchStyle["Multiple"] = "multiple";
})(AtomistSkillEventDispatchStyle = exports.AtomistSkillEventDispatchStyle || (exports.AtomistSkillEventDispatchStyle = {}));
var AtomistSkillParameterVisiblity;
(function (AtomistSkillParameterVisiblity) {
    AtomistSkillParameterVisiblity["Hidden"] = "hidden";
    AtomistSkillParameterVisiblity["Advanced"] = "advanced";
    AtomistSkillParameterVisiblity["Normal"] = "normal";
})(AtomistSkillParameterVisiblity = exports.AtomistSkillParameterVisiblity || (exports.AtomistSkillParameterVisiblity = {}));
var AtomistSkillStringParameterLineStyle;
(function (AtomistSkillStringParameterLineStyle) {
    AtomistSkillStringParameterLineStyle["Single"] = "single";
    AtomistSkillStringParameterLineStyle["Multiple"] = "multiple";
})(AtomistSkillStringParameterLineStyle = exports.AtomistSkillStringParameterLineStyle || (exports.AtomistSkillStringParameterLineStyle = {}));
var AtomistSkillTechnology;
(function (AtomistSkillTechnology) {
    AtomistSkillTechnology["Java"] = "JAVA";
    AtomistSkillTechnology["Maven"] = "MAVEN";
    AtomistSkillTechnology["Docker"] = "DOCKER";
    AtomistSkillTechnology["Javascript"] = "JAVASCRIPT";
    AtomistSkillTechnology["Npm"] = "NPM";
    AtomistSkillTechnology["Lein"] = "LEIN";
    AtomistSkillTechnology["Clojure"] = "CLOJURE";
    AtomistSkillTechnology["Kubernetes"] = "KUBERNETES";
})(AtomistSkillTechnology = exports.AtomistSkillTechnology || (exports.AtomistSkillTechnology = {}));
async function createJavaScriptSkillInput(cwd, genArtifacts, name = "index.js") {
    var _a, _b, _c, _d;
    const p = path.join(cwd, name);
    log_1.info(`Generating skill metadata...`);
    const is = merge({}, await skill_container_1.defaults(cwd), await util_2.handleError(async () => await (await Promise.resolve().then(() => require(p))).Skill, () => {
        log_1.error(`Error loading '${p}'`);
        return {};
    }));
    if (!is) {
        throw new Error(`Failed to load exported Skill constant from '${p}'`);
    }
    const rc = content(cwd);
    const subscriptions = [];
    for (const subscription of is.subscriptions || [
        "file://**/graphql/subscription/*.graphql",
    ]) {
        const subs = (await rc(subscription)).map(s => s
            .replace(/\$\{namespace\}/g, is.namespace)
            .replace(/\$\{name\}/g, is.name));
        subscriptions.push(...subs);
    }
    const datalogSubscriptions = [...(is.datalogSubscriptions || [])];
    datalogSubscriptions.push(...(await util_1.withGlobMatches(cwd, "**/datalog/subscription/*.edn", async (file) => {
        const filePath = path.join(cwd, file);
        const fileName = path.basename(filePath);
        const extName = path.extname(fileName);
        return {
            query: (await fs.readFile(path.join(cwd, file))).toString(),
            name: fileName.replace(extName, ""),
        };
    })));
    datalogSubscriptions.forEach(dl => {
        if (dl.query.startsWith("@")) {
            dl.query = named_1.namedDatalog(dl.query);
        }
    });
    const schemata = [...(is.schemata || [])];
    if (schemata.length === 0) {
        schemata.push(...(await util_1.withGlobMatches(cwd, "**/datalog/schema/*.{json,edn}", async (file) => {
            const filePath = path.join(cwd, file);
            const fileName = path.basename(filePath);
            const extName = path.extname(fileName);
            let schema = (await fs.readFile(path.join(cwd, file))).toString();
            if (file.endsWith(".json")) {
                schema = edn_data_1.toEDNStringFromSimpleObject(JSON.parse(schema));
            }
            return {
                schema,
                name: fileName.replace(extName, ""),
            };
        })));
    }
    const artifacts = {};
    if (genArtifacts) {
        if (!is.containers) {
            artifacts.gcf = [
                {
                    entryPoint: ((_a = is.runtime) === null || _a === void 0 ? void 0 : _a.entryPoint) || "entryPoint",
                    memory: ((_b = is.runtime) === null || _b === void 0 ? void 0 : _b.memory) || 512,
                    timeout: ((_c = is.runtime) === null || _c === void 0 ? void 0 : _c.timeout) || 60,
                    runtime: ((_d = is.runtime) === null || _d === void 0 ? void 0 : _d.platform) ||
                        AtomistSkillRuntime.Nodejs14,
                    name: "gcf",
                    url: undefined,
                },
            ];
        }
        else {
            artifacts.docker = map(is.containers, (v, k) => (Object.assign({ name: k }, v)));
        }
    }
    const y = {
        name: is.name,
        namespace: is.namespace,
        displayName: is.displayName,
        version: is.version,
        author: is.author,
        description: is.description,
        longDescription: is.longDescription,
        license: is.license,
        categories: is.categories,
        technologies: is.technologies,
        homepageUrl: is.homepageUrl,
        iconUrl: await icon(cwd, is.iconUrl),
        videoUrl: is.videoUrl,
        readme: is.readme
            ? Buffer.from(is.readme).toString("base64")
            : undefined,
        maxConfigurations: is.maxConfigurations,
        artifacts,
        resourceProviders: map(is.resourceProviders || {}, (v, k) => ({
            name: k,
            displayName: v.displayName,
            typeName: v.typeName,
            description: v.description,
            minRequired: v.minRequired,
            maxAllowed: v.maxAllowed,
        })),
        parameters: map(is.parameters || {}, (v, k) => {
            const type = v.type;
            delete v.type;
            return {
                [type]: Object.assign({ name: k }, v),
            };
        }),
        commands: (is.commands || []).map(c => ({
            name: c.name,
            displayName: c.displayName,
            description: c.description,
            pattern: c.pattern.source,
        })),
        subscriptions,
        datalogSubscriptions,
        schemata,
        capabilities: is.capabilities,
    };
    if (!y.longDescription) {
        y.longDescription = y.description;
    }
    return y;
}
exports.createJavaScriptSkillInput = createJavaScriptSkillInput;
async function validateSkillInput(cwd, s, options = { validateHandlers: true }) {
    const errors = [];
    // Check required fields
    const requiredFields = [
        "name",
        "namespace",
        "description",
        "longDescription",
        "author",
        "homepageUrl",
        "iconUrl",
        "license",
    ];
    for (const requiredField of requiredFields) {
        if (!s[requiredField]) {
            errors.push(`Required field '${requiredField}' missing`);
        }
    }
    // Check categories against schema
    for (const category of s.categories || []) {
        if (!Object.values(AtomistSkillCategoryKey).includes(category)) {
            errors.push(`Category '${category}' invalid`);
        }
    }
    // Check technologies against schema
    for (const technology of s.technologies || []) {
        if (!Object.values(AtomistSkillTechnology).includes(technology)) {
            errors.push(`Technology '${technology}' invalid`);
        }
    }
    if (options.validateHandlers) {
        // Validate commands
        for (const command of s.commands || []) {
            await util_2.handleError(async () => {
                const p = await util_2.handlerLoader(`commands/${command.name}`);
                if (!p) {
                    errors.push(`Registered command '${command.name}' can't be found`);
                }
            }, err => {
                errors.push(`Registered command '${command.name}' can't be found: ${err.message}`);
            });
        }
        // Validate subscriptions
        for (const subscription of s.subscriptions || []) {
            const match = subscription.match(/subscription\s([^\s({]+)[\s({]/);
            if (match) {
                const operationName = match[1];
                await util_2.handleError(async () => {
                    const p = await util_2.handlerLoader(`events/${operationName}`);
                    if (!p) {
                        errors.push(`Registered event handler '${operationName}' can't be found`);
                    }
                }, err => {
                    errors.push(`Registered event handler '${operationName}' can't be found: ${err.message}`);
                });
            }
        }
    }
    if (errors.length > 0) {
        log_1.error(`Skill metadata contains errors:
${errors.map(e => `        - ${e}`).join("\n")}`);
        throw new Error(`Failed to generate skill metadata`);
    }
}
exports.validateSkillInput = validateSkillInput;
async function generateSkill(cwd, validate, artifacts) {
    let s;
    let forceValidate = validate;
    if (forceValidate === undefined) {
        forceValidate = await fs.pathExists(path.join(cwd, "package.json"));
    }
    if (await fs.pathExists(path.join(cwd, "skill.js"))) {
        s = await createJavaScriptSkillInput(cwd, artifacts, "skill.js");
        await validateSkillInput(cwd, s, { validateHandlers: forceValidate });
    }
    else {
        s = await skill_container_1.createYamlSkillInput(cwd, artifacts);
        await validateSkillInput(cwd, s, { validateHandlers: forceValidate });
    }
    await writeSkillYaml(cwd, s);
}
exports.generateSkill = generateSkill;
async function writeSkillYaml(cwd, skill) {
    const p = path.join(cwd, ".atomist", "skill.yaml");
    await fs.ensureDir(path.dirname(p));
    const yaml = await Promise.resolve().then(() => require("js-yaml"));
    const content = yaml.dump({
        apiVersion: 1,
        skill,
    }, { skipInvalid: true });
    await fs.writeFile(p, content);
    log_1.info(`Written skill metadata to '${p}'`);
}
exports.writeSkillYaml = writeSkillYaml;
function content(cwd) {
    return async (key) => {
        if (!key) {
            return [];
        }
        if (key.startsWith("file://")) {
            const pattern = key.slice(7);
            return util_1.withGlobMatches(cwd, pattern, async (file) => {
                return (await fs.readFile(path.join(cwd, file))).toString();
            });
        }
        else if (key.startsWith("@")) {
            return [named_1.namedGraphQl(key)];
        }
        else {
            return [key];
        }
    };
}
exports.content = content;
async function icon(cwd, key) {
    if (!key) {
        return undefined;
    }
    if (key.startsWith("file://")) {
        const data = await content(cwd)(key);
        if ((data === null || data === void 0 ? void 0 : data.length) > 0) {
            return `data:image/svg+xml;base64,${Buffer.from(data[0]).toString("base64")}`;
        }
        else {
            return undefined;
        }
    }
    else {
        return key;
    }
}
exports.icon = icon;
//# sourceMappingURL=skill_input.js.map