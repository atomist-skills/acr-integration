import { DatalogClient } from "../datalog/client";
import { GraphQLClient } from "../graphql";
import { HttpClient } from "../http";
import { CommandMessageClient, MessageClient } from "../message";
import { CommandIncoming, EventIncoming, SubscriptionIncoming, WebhookIncoming } from "../payload";
import { ProjectLoader } from "../project/index";
import { ParameterPromptObject, ParameterPromptOptions } from "../prompt/prompt";
import { CredentialProvider } from "../secret/provider";
import { StorageProvider } from "../storage/provider";
export interface Configuration<C extends Record<string, any>> {
    name: string;
    parameters: C;
    resourceProviders: Record<string, {
        typeName: string;
        selectedResourceProviders: Array<{
            id: string;
        }>;
    }>;
    url: string;
}
export interface Contextual<T, C> {
    name: string;
    workspaceId: string;
    correlationId: string;
    executionId: string;
    credential: CredentialProvider;
    graphql: GraphQLClient;
    datalog: DatalogClient;
    http: HttpClient;
    message: MessageClient;
    project: ProjectLoader;
    storage: StorageProvider;
    trigger: T;
    configuration: C;
    skill: {
        id: string;
        name: string;
        namespace: string;
        version: string;
    };
    /** Register a callback that gets executed when the skill execution is complete */
    onComplete: (callback: () => Promise<void>) => void;
}
/**
 * Internal extension to the Contextual interface providing
 * lifecycle methods
 */
export interface ContextualLifecycle {
    close: () => Promise<void>;
}
export interface EventContext<E = any, C = any, P = EventIncoming | SubscriptionIncoming> extends Contextual<P, Configuration<C>> {
    data: E;
}
export interface CommandContext<C = any> extends Contextual<CommandIncoming, Array<Configuration<C>>> {
    parameters: {
        prompt<PARAMS = any>(parameters: ParameterPromptObject<PARAMS>, options?: ParameterPromptOptions): Promise<PARAMS>;
    };
    message: CommandMessageClient;
}
export interface WebhookContext<B = any, C = any> extends Contextual<WebhookIncoming, Configuration<C>> {
    headers: Record<string, string>;
    body: string;
    json: B;
    url: string;
    name: string;
}
export interface HandlerStatus {
    visibility?: "hidden" | "visible";
    code?: number;
    reason?: string;
}
export declare type CommandHandler<C = any> = (context: CommandContext<C>) => Promise<void | HandlerStatus>;
export declare type EventHandler<E = any, C = any> = (context: EventContext<E, C>) => Promise<void | HandlerStatus>;
export declare type MappingEventHandler<E = any, R = any, C = any> = {
    handle: EventHandler<E, C>;
    map: (data: R[]) => E;
};
export declare type WebhookHandler<B = any, C = any> = (context: WebhookContext<B, C>) => Promise<void | HandlerStatus>;
//# sourceMappingURL=handler.d.ts.map