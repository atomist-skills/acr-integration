"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.sourceLocationFromOffset = exports.isPrimitive = exports.levenshteinSort = exports.pluralize = exports.isStaging = exports.DefaultErrorHandler = exports.handleErrorSync = exports.handleError = exports.bytes = exports.guid = exports.hideString = exports.replacer = exports.extractParameters = exports.requirePath = exports.handlerLoader = exports.toArray = exports.truncate = exports.hash = void 0;
const crypto = require("crypto");
const fs = require("fs-extra");
const path = require("path");
const uuid_1 = require("uuid");
const log_1 = require("./log");
const sortBy = require("lodash.sortby");
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function hash(obj) {
    const hash = crypto.createHash("sha256");
    hash.update(typeof obj === "string" ? obj : JSON.stringify(obj));
    return hash.digest("hex");
}
exports.hash = hash;
function truncate(text, length, options = {
    direction: "middle",
    separator: "...",
}) {
    if (text.length <= length) {
        return text;
    }
    const separatorLength = options.separator.length;
    if (options.direction === "start") {
        return `${options.separator}${text.slice(text.length - length + separatorLength)}`;
    }
    else if (options.direction === "end") {
        return `${text.slice(0, length - separatorLength)}${options.separator}`;
    }
    else if (options.direction === "middle") {
        const charsToShow = length - separatorLength;
        const frontChars = Math.ceil(charsToShow / 2);
        const backChars = Math.floor(charsToShow / 2);
        return `${text.slice(0, frontChars)}${options.separator}${text.slice(text.length - backChars)}`;
    }
    return text;
}
exports.truncate = truncate;
function toArray(value) {
    if (value) {
        if (Array.isArray(value)) {
            return value;
        }
        else {
            return [value];
        }
    }
    else {
        return undefined;
    }
}
exports.toArray = toArray;
function handlerLoader(type) {
    return async (name, cwd) => {
        const path = await requirePath(type, name, cwd);
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const f = require(path);
        if (f[name]) {
            return f[name];
        }
        else if (f.handler) {
            return f.handler;
        }
        else {
            throw new Error(`No ${type} handler found for '${name}'`);
        }
    };
}
exports.handlerLoader = handlerLoader;
async function requirePath(type, file, cwd) {
    const p = cwd || __dirname.split("/node_modules/")[0];
    const rp = path.join(p, type, file);
    const lp = path.join(p, "lib", type, file);
    if (await fs.pathExists(rp + ".js")) {
        return rp;
    }
    else if (await fs.pathExists(lp + ".js")) {
        return lp;
    }
    // Test the fallback
    const f = path.join(p, type);
    const fl = path.join(p, "lib", type);
    if (await fs.pathExists(f + ".js")) {
        return f;
    }
    else if (await fs.pathExists(fl + ".js")) {
        return fl;
    }
    throw new Error(`'${file}' not found in '${p}' or '${p}/lib'`);
}
exports.requirePath = requirePath;
function extractParameters(intent) {
    const args = [];
    // eslint-disable-next-line no-useless-escape
    const regexp = /^[a-zA-Z\s]*(\s+--([a-z.A-Z_]*)=(?:'([^']*?)'|"([^"]*?)"|([\w\-\.]*?)))*$/g;
    let intentToMatch = intent.trim();
    let match = regexp.exec(intentToMatch);
    while (!!match && !!match[1] && !!match[2]) {
        const name = match[2];
        const value = match[3] || match[4] || match[5];
        args.push({ name, value });
        intentToMatch = intentToMatch.replace(match[1], "").trim();
        regexp.lastIndex = 0;
        match = regexp.exec(intentToMatch);
    }
    return args
        .reduce((p, c) => {
        if (!p.some(e => e.name === c.name)) {
            p.push(c);
        }
        return p;
    }, [])
        .reverse();
}
exports.extractParameters = extractParameters;
function keyToHide(key) {
    return /token|password|jwt|url|secret|authorization|key|cert|pass|user|address|email/i.test(key);
}
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function replacer(key, value) {
    if (key === "parameters" && value) {
        return value.map(v => {
            let value = v.value;
            if (keyToHide(v.name)) {
                value = hideString(v.value);
            }
            return { name: v.name, value };
        });
    }
    else if (key === "secrets" && value) {
        return value.map(v => ({ uri: v.uri, value: hideString(v.value) }));
    }
    else if (keyToHide(key)) {
        return hideString(value);
    }
    else {
        return value;
    }
}
exports.replacer = replacer;
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function hideString(value) {
    if (!value) {
        return value;
    }
    if (typeof value === "string") {
        let newValue = "";
        for (let i = 0; i < value.length; i++) {
            if (i === 0) {
                newValue = value.charAt(0);
            }
            else if (i < value.length - 1) {
                newValue += "*";
            }
            else {
                newValue += value.slice(-1);
            }
        }
        return newValue;
    }
    else if (Array.isArray(value)) {
        return value.map(hideString);
    }
    return value;
}
exports.hideString = hideString;
function guid() {
    return uuid_1.v4();
}
exports.guid = guid;
const units = ["b", "kb", "mb", "gb", "tb", "pb"];
function bytes(x) {
    if (x === undefined || isNaN(+x)) {
        return x;
    }
    let l = 0;
    let n = parseInt(x, 10) || 0;
    while (n >= 1024 && ++l) {
        n = n / 1024;
    }
    return n.toFixed(n < 10 && l > 0 ? 1 : 0) + "" + units[l];
}
exports.bytes = bytes;
async function handleError(f, cb = exports.DefaultErrorHandler) {
    try {
        const result = await f();
        return result;
    }
    catch (e) {
        return cb(e);
    }
}
exports.handleError = handleError;
function handleErrorSync(f, cb = exports.DefaultErrorHandler) {
    try {
        return f();
    }
    catch (e) {
        return cb(e);
    }
}
exports.handleErrorSync = handleErrorSync;
const DefaultErrorHandler = err => {
    log_1.error(`Error occurred: %s`, err.message);
    if (err.stack) {
        log_1.error(err.stack);
    }
    return undefined;
};
exports.DefaultErrorHandler = DefaultErrorHandler;
function isStaging() {
    return (process.env.ATOMIST_GRAPHQL_ENDPOINT ||
        "https://automation.atomist.com/graphql").includes(".services");
}
exports.isStaging = isStaging;
function pluralize(text, count, options = {
    include: true,
    includeOne: false,
}) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const plu = require("pluralize");
    const countNumber = typeof count === "number" ? count : count.length;
    return plu(text, countNumber, countNumber === 1 ? options.includeOne : options.include);
}
exports.pluralize = pluralize;
function levenshteinSort(word, elements) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const { distance } = require("fastest-levenshtein");
    return sortBy([...elements], o => distance(word, o));
}
exports.levenshteinSort = levenshteinSort;
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function isPrimitive(test) {
    return test !== Object(test);
}
exports.isPrimitive = isPrimitive;
function sourceLocationFromOffset(match, offset, content) {
    const startLine = (content.slice(0, offset).match(/\n/gm) || []).length + 1;
    const endLine = startLine +
        (content.slice(offset, offset + match.length).match(/\n/gm) || [])
            .length;
    let startOffset;
    let endOffset;
    if (startLine === endLine) {
        startOffset = offset - content.slice(0, offset).lastIndexOf("\n");
        endOffset = startOffset + match.length;
    }
    return {
        startLine,
        startOffset,
        endLine,
        endOffset,
    };
}
exports.sourceLocationFromOffset = sourceLocationFromOffset;
//# sourceMappingURL=util.js.map