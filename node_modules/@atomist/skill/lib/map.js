"use strict";
/*
 * Copyright Â© 2021 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapSubscription = exports.wrapEventHandler = void 0;
const camelCase = require("lodash.camelcase");
const console_1 = require("./log/console");
const message_1 = require("./message");
const util_1 = require("./util");
function wrapEventHandler(eh) {
    return async (ctx) => {
        const meh = eh;
        if (typeof meh !== "function" && meh.map && meh.handle) {
            const data = meh.map(ctx.data);
            return meh.handle(Object.assign(Object.assign({}, ctx), { data }));
        }
        if (Array.isArray(ctx.data)) {
            const results = [];
            for (const event of ctx.data) {
                try {
                    const result = await eh(Object.assign(Object.assign({}, ctx), { data: event }));
                    if (result) {
                        results.push(result);
                    }
                }
                catch (e) {
                    console_1.error(`Error occurred: ${e.stack}`);
                    results.push(message_1.prepareStatus(e, ctx));
                }
            }
            return {
                code: results.reduce((p, c) => {
                    if (c.code !== 0) {
                        return c.code;
                    }
                    else {
                        return 0;
                    }
                }, 0),
                reason: results
                    .filter(r => r.reason)
                    .filter(r => r.visibility !== "hidden")
                    .map(r => r.reason)
                    .join(", "),
                visibility: results.some(r => r.visibility !== "hidden")
                    ? undefined
                    : "hidden",
            };
        }
        else {
            return eh(ctx);
        }
    };
}
exports.wrapEventHandler = wrapEventHandler;
/**
 * Map a Datalog subscription result to a JavaScript object
 */
function mapSubscription(result) {
    if (!result) {
        return undefined;
    }
    const mapped = {};
    const mapper = (v) => {
        if (util_1.isPrimitive(v)) {
            return v;
        }
        else if (Array.isArray(v)) {
            return v.map(vr => mapper(vr));
        }
        else {
            // Special case for enums
            const values = Object.keys(v);
            if (values.length === 2 &&
                values.includes("db/id") &&
                values.includes("db/ident")) {
                return nameFromKey(v["db/ident"], false);
            }
            const m = {};
            for (const k in v) {
                m[nameFromKey(k)] = mapper(v[k]);
            }
            return m;
        }
    };
    util_1.toArray(result).forEach(r => {
        const value = {};
        const key = nameFromKey(r["schema/entity-type"] || "unknownEntity");
        for (const k in r) {
            if (k !== "schema/entity-type") {
                value[nameFromKey(k)] = mapper(r[k]);
            }
        }
        if (Array.isArray(mapped[key])) {
            mapped[key].push(value);
        }
        else if (mapped[key]) {
            mapped[key] = [mapped[key], value];
        }
        else {
            mapped[key] = value;
        }
    });
    return mapped;
}
exports.mapSubscription = mapSubscription;
function nameFromKey(value, toCamelCase = true) {
    let name;
    if (value.includes("/")) {
        name = value.split("/")[1];
    }
    else {
        name = value;
    }
    if (toCamelCase) {
        return camelCase(name);
    }
    else {
        return name;
    }
}
//# sourceMappingURL=map.js.map