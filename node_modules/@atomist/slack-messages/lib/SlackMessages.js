"use strict";
/*
 * Copyright © 2020 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.listItem = exports.codeBlock = exports.codeLine = exports.strikethrough = exports.italic = exports.bold = exports.emoji = exports.render = exports.atEveryone = exports.atHere = exports.atChannel = exports.channel = exports.user = exports.url = exports.escape = exports.MessageMimeTypes = void 0;
const splitProcessor_1 = require("./splitProcessor");
/**
 * Helper constants for the MIME types the Slack message API accepts.
 */
exports.MessageMimeTypes = {
    SlackJson: "application/x-atomist-slack+json",
    SlackFileJson: "application/x-atomist-slack-file+json",
    PlainText: "text/plain",
    ApplicationJson: "application/json",
};
/**
 * Construct and render slack messages according to Slack message
 * formatting: https://api.slack.com/docs/message-formatting. Customize
 * messages with rug actions.
 */
/**
 * Encode special Slack characters and HTML entities.
 */
function escape(text) {
    if (text) {
        const entify = (i) => i
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");
        const htmlEntities = /(&(?:\w+|#\d+);)/;
        return splitProcessor_1.splitProcessor(text, entify, htmlEntities);
    }
    else {
        return "";
    }
}
exports.escape = escape;
/**
 * Constructs slack link.
 * Label is automatically escaped.
 */
function url(fullUrl, label) {
    if (fullUrl && label) {
        return `<${fullUrl}|${escape(label)}>`;
    }
    else if (fullUrl) {
        return `<${fullUrl}>`;
    }
    else {
        return "";
    }
}
exports.url = url;
/**
 * Mentions user (e.g. @anna).
 * When userName is provided will add readable user name.
 *
 * @param userId Slack user ID
 * @param userName alternative user name, which Slack seems to ignore
 * @return properly formatted Slack user mention
 */
function user(userId, userName) {
    if (userId && userName) {
        return `<@${userId}|${userName}>`;
    }
    else if (userId) {
        return `<@${userId}>`;
    }
    else {
        return "";
    }
}
exports.user = user;
/**
 * Mentions channel (e.g. #general).
 * Will mention specific channel by channelId.
 * When channelName is provided will add readable channel name.
 */
function channel(channelId, channelName) {
    if (channelId && channelName) {
        return `<#${channelId}|${channelName}>`;
    }
    else if (channelId) {
        return `<#${channelId}>`;
    }
    else {
        return "";
    }
}
exports.channel = channel;
/** Mentions @channel */
function atChannel() {
    return "<!channel>";
}
exports.atChannel = atChannel;
/** Mentions here (@here) */
function atHere() {
    return "<!here>";
}
exports.atHere = atHere;
/** Mentions everyone (@everyone) */
function atEveryone() {
    return "<!everyone>";
}
exports.atEveryone = atEveryone;
/** Renders JSON representation of slack message. */
function render(message, pretty = false) {
    if (message.attachments && message.attachments.length > 0) {
        let idx = 1;
        message.attachments.forEach(att => {
            if (att.actions && att.actions.length > 0 && !att.callback_id) {
                att.callback_id = `cllbck${idx++}`;
            }
        });
    }
    if (message.blocks && message.blocks.length > 0) {
        if (!message.text) {
            message.text = "fallback";
        }
        message.blocks = JSON.stringify(message.blocks);
    }
    return JSON.stringify(message, undefined, pretty ? 2 : 0);
}
exports.render = render;
/** Render emoji by name */
function emoji(name) {
    return name ? `:${name}:` : "";
}
exports.emoji = emoji;
/** Render bold text */
function bold(text) {
    return text ? `*${text}*` : "";
}
exports.bold = bold;
/** Render italic text */
function italic(text) {
    return text ? `_${text}_` : "";
}
exports.italic = italic;
/** Render strike-through text */
function strikethrough(text) {
    return text ? `~${text}~` : "";
}
exports.strikethrough = strikethrough;
/** Render single line code block */
function codeLine(text) {
    return text ? "`" + text + "`" : "";
}
exports.codeLine = codeLine;
/** Render multiline code block */
function codeBlock(text) {
    return text ? "```" + text + "```" : "";
}
exports.codeBlock = codeBlock;
/** Render bullet list item */
function listItem(item) {
    return item ? `• ${item}` : "";
}
exports.listItem = listItem;
//# sourceMappingURL=SlackMessages.js.map