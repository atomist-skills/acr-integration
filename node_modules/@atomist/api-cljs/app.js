const { PubSub } = require('@google-cloud/pubsub');
const { Storage } = require('@google-cloud/storage');
const { resolvePayload } = require("@atomist/skill/lib/payload_resolve");
const pubsub = new PubSub();
const storage = new Storage();
const main = require('../../../index.js');

/**
 * We have to construct these MessageClients because we control the messaging layer
 * on behalf of users
 * This implementation takes an JS obj
 * @param {*} s
 */
const sendreponse = async function (correlationId, obj) {
  const topic = pubsub.topic(process.env.TOPIC, {messageOrdering: true});

  const messageBuffer = Buffer.from(JSON.stringify(obj), 'utf8')

  // Publishes a message
  try {
    return await topic.publishMessage({data: messageBuffer, orderingKey: correlationId});
  } catch (err) {
    console.error(err);
    return Promise.reject(err);
  }
}

/**
 * Export one function to gcf - we should generate this ourselves
 *   - the pubSubEvent contains a CommandHandlerRequest
 *   - for a serverless CommandHandler, we should create the SDM HandlerContext from this data
 *   - we should also construct the sendreponse function that we provide for sending CommandHandlerReponse messages
 *   - we have to control the implementation of sendreponse but it can be folded into the MessageClient
 */
exports.eventhandler = async (pubSubEvent, context) => {
  const handler = main.handler || main.atomist.main.handler || main.stupendabot.main.handler;
  const event = await resolvePayload(pubSubEvent);
  event.eventId = context.eventId;
//  console.log(event);
  return handler(event, sendreponse);
}
